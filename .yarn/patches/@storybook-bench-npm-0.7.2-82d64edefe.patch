diff --git a/dist/bench.cjs.development.js b/dist/bench.cjs.development.js
index 4054e03b61fd8cf7e76a7c393b664f530796257e..1bb7b564e4e4354fca9dc10c0c19af873e936f46 100644
--- a/dist/bench.cjs.development.js
+++ b/dist/bench.cjs.development.js
@@ -56,8 +56,7 @@ function _catch(body, recover) {
 	return result;
 }
 
-var EVENTS = ['managerRender', 'previewRender']; // , 'storyRender'
-
+var EVENTS = ['managerRender', 'previewRender', 'storyRender'];
 var STATS_PORT = 9898;
 var puppeteerArgs = ['--no-sandbox', '--disable-setuid-sandbox'];
 
@@ -94,7 +93,7 @@ var makeStatsServer = function makeStatsServer(stats, done) {
               stats.time[event] = (now() - stats.init) * 1000000;
             }
 
-            if (event === 'previewRender') {
+            if (event === 'storyRender') {
               done();
             }
 
@@ -437,7 +436,11 @@ var startStorybook = function startStorybook(extraFlags) {
       stdio: 'pipe'
     });
     var managerWebpack = -1;
-    var previewWebpack = -1;
+    var previewWebpack = -1; // Needed for webpack 4
+    // child.stderr.on('data', d => {
+    //   console.log(d.toString());
+    // });
+
     child.stdout.on('data', function (data) {
       var output = data.toString(); //â”‚   8.42 s for manager and 8.86 s for preview       â”‚
 
@@ -488,7 +491,7 @@ var startStorybook = function startStorybook(extraFlags) {
         statsServer = _makeStatsServer;
         return Promise.resolve(buildFinished).then(function () {
           return Promise.resolve(browser.newPage()).then(function (page) {
-            return Promise.resolve(page["goto"]("http://localhost:" + DEV_PORT + "/index.html")).then(function () {
+            return Promise.resolve(page["goto"]("http://localhost:" + DEV_PORT)).then(function () {
               return Promise.resolve(renderFinished).then(function () {
                 var webpackStats = {
                   managerWebpack: managerWebpack,
@@ -614,36 +617,27 @@ var save = function save(results, label) {
 var benchmark = function benchmark(_ref) {
   var installCommand = _ref.installCommand,
       label = _ref.label,
-      extraFlags = _ref.extraFlags,
-      benchmarks = _ref.benchmarks;
+      extraFlags = _ref.extraFlags;
 
   try {
     return Promise.resolve(cleanup()).then(function () {
-      function _temp3(install) {
-        function _temp2(start) {
-          function _temp(browse) {
-            var bench = formatNumber(_extends({
+      return Promise.resolve(installStorybook(installCommand)).then(function (install) {
+        return Promise.resolve(startStorybook(extraFlags)).then(function (start) {
+          return Promise.resolve(buildBrowseStorybook(extraFlags)).then(function (_ref2) {
+            var build = _ref2.build,
+                browse = _ref2.browse;
+            var bench = formatNumber({
               install: install,
-              start: start
-            }, browse));
+              start: start,
+              build: build,
+              browse: browse
+            });
             return Promise.resolve(save(bench, label)).then(function () {
               return bench;
             });
-          }
-
-          var _benchmarks$browse = benchmarks.browse;
-          return _benchmarks$browse ? Promise.resolve(buildBrowseStorybook(extraFlags)).then(_temp) : _temp({
-            build: {},
-            browse: {}
           });
-        }
-
-        var _benchmarks$start = benchmarks.start;
-        return _benchmarks$start ? Promise.resolve(startStorybook(extraFlags)).then(_temp2) : _temp2({});
-      }
-
-      var _benchmarks$install = benchmarks.install;
-      return _benchmarks$install ? Promise.resolve(installStorybook(installCommand)).then(_temp3) : _temp3({});
+        });
+      });
     });
   } catch (e) {
     return Promise.reject(e);
@@ -652,42 +646,31 @@ var benchmark = function benchmark(_ref) {
 
 var main = function main() {
   try {
-    program.arguments('[installCommand]');
+    program.arguments('<installCommand>');
     program.option('-l, --label <label>', 'Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true', 'bench');
     program.option('-e, --extra-flags <flags>', 'Run storybook with extra flags (e.g. "--no-dll")', '');
-    program.option('--no-install', 'Do not measure storybook install time');
-    program.option('--no-start', 'Do not measure storybook start time');
-    program.option('--no-browse', 'Do not measure storybook browse time');
     program.parse(process.argv);
 
-    if (program.install && !program.args.length) {
+    if (!program.args.length) {
       program.help();
     }
 
     var label = program.label,
-        extraFlags = program.extraFlags,
-        install = program.install,
-        start = program.start,
-        browse = program.browse;
+        extraFlags = program.extraFlags;
     var installCommand = program.args[0];
     var flags = extraFlags.length > 0 ? extraFlags.split(' ') : [];
     return Promise.resolve(benchmark({
       installCommand: installCommand,
       label: label,
-      extraFlags: flags,
-      benchmarks: {
-        install: install,
-        start: start,
-        browse: browse
-      }
+      extraFlags: flags
     })).then(function (bench) {
-      var _temp4 = function () {
+      var _temp = function () {
         if (SB_BENCH_UPLOAD) {
           return Promise.resolve(upload(bench, label)).then(function () {});
         }
       }();
 
-      if (_temp4 && _temp4.then) return _temp4.then(function () {});
+      if (_temp && _temp.then) return _temp.then(function () {});
     });
   } catch (e) {
     return Promise.reject(e);
diff --git a/dist/bench.cjs.development.js.map b/dist/bench.cjs.development.js.map
index fb2001245a7fce13c04dd427ebc8663f01dd3415..89967061a5786d6fbdc3ebc6048a299ed2495d00 100644
--- a/dist/bench.cjs.development.js.map
+++ b/dist/bench.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"bench.cjs.development.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/helpers/timing.ts","../src/helpers/static.ts","../src/buildBrowseStorybook.ts","../src/installAddonBench.ts","../src/installStorybook.ts","../src/startStorybook.ts","../src/environment.ts","../src/upload.ts","../src/helpers/format.ts","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import Hapi from '@hapi/hapi';\n\nexport const EVENTS = ['managerRender', 'previewRender']; // , 'storyRender'\nexport const STATS_PORT = 9898;\n\nexport type Stats = {\n  init: number;\n  time: Record<string, number | null>;\n};\n\nexport const puppeteerArgs = ['--no-sandbox', '--disable-setuid-sandbox'];\n\nconst now = () => new Date().getTime();\n\nexport const resetStats = (stats?: Stats) => {\n  const result = stats || ({ init: now(), time: {} } as Stats);\n  result.init = now();\n  EVENTS.forEach(evt => (result.time[evt] = null));\n  return result;\n};\n\nexport const makeStatsServer = async (stats: Stats, done: any) => {\n  const server = new Hapi.Server({ port: STATS_PORT });\n\n  const addEvent = (event: string) => {\n    server.route({\n      method: 'GET',\n      path: `/${event}`,\n      handler: async (req: any, h: any) => {\n        console.log(`HANDLER: ${event}`, stats);\n        if (!stats.time[event]) {\n          stats.time[event] = (now() - stats.init) * 1000000;\n        }\n        if (event === 'previewRender') {\n          done();\n        }\n        return h.response('ok').code(200);\n      },\n    });\n  };\n\n  EVENTS.forEach(evt => addEvent(evt));\n  await server.start();\n  return server;\n};\n","import Hapi from '@hapi/hapi';\nimport Inert from '@hapi/inert';\nimport path from 'path';\n\nexport const STATIC_STORYBOOK_PORT = 9899;\n\nexport const makeStaticServer = async () => {\n  const server = new Hapi.Server({\n    port: STATIC_STORYBOOK_PORT,\n  });\n  await server.register(Inert);\n\n  server.route({\n    method: 'GET',\n    path: '/{param*}',\n    handler: async (req, h) => {\n      const filePath = path.join(process.cwd(), 'storybook-static', req.path);\n      return h.file(filePath, { confine: false });\n    },\n  });\n\n  await server.start();\n  console.log('Static server:', server.info.uri);\n  return server;\n};\n","import { Tick, timers } from 'exectimer';\nimport { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport fs from 'fs';\nimport path from 'path';\nimport rimraf from 'rimraf';\nimport puppeteer from 'puppeteer';\n\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport { makeStaticServer, STATIC_STORYBOOK_PORT } from './helpers/static';\n\nconst STDIO = 'inherit';\nconst BUILD_DIR = 'storybook-static';\n\nconst SCRIPT_REGEX = /<script.*?src=\"(.[^\"]*\\.js)\">/g;\nconst logger = console;\n\nconst getScripts = (html: string) => {\n  // <script src=\"runtime~main.6a9b04192e3176eff72a.bundle.js\">\n  return Array.from(html.matchAll(SCRIPT_REGEX)).map(m => m[1]);\n};\n\nconst bundleSize = async (\n  buildDir: string,\n  prefix: string,\n  iframeScripts: string[],\n  indexScripts: string[]\n) => {\n  let preview = iframeScripts.find(f => f.startsWith(prefix));\n  let manager = indexScripts.find(f => f.startsWith(prefix));\n\n  // FIXME: webpack5 uses `290.d3d846e4d074e7386081.bundle.js`\n  if (prefix === 'vendors') {\n    manager =\n      manager ||\n      indexScripts.find(f => !f.startsWith('main') && !f.startsWith('runtime'));\n    preview =\n      preview ||\n      iframeScripts.find(\n        f => !f.startsWith('main') && !f.startsWith('runtime')\n      );\n  }\n\n  // FIXME: vite uses '/assets/iframe.d7d1f891.js`, no vendors or runtime\n  if (!preview && prefix === 'main') {\n    preview = iframeScripts.find(f => f.startsWith('/assets/iframe'));\n  }\n\n  if (!manager) {\n    throw new Error(`Missing manager files for '${prefix}')}`);\n  }\n\n  return {\n    manager: await du(path.join(buildDir, manager)),\n    preview: preview ? await du(path.join(buildDir, preview)) : 0,\n  };\n};\n\nconst safeDu = async (filePath: string) => {\n  try {\n    return await du(filePath);\n  } catch {\n    return 0;\n  }\n};\n\nexport const bundleSizes = async (buildDir: string) => {\n  const iframe = getScripts(\n    fs.readFileSync(path.join(buildDir, 'iframe.html')).toString()\n  );\n  const index = getScripts(\n    fs.readFileSync(path.join(buildDir, 'index.html')).toString()\n  );\n\n  const [main, runtime, vendors, docsDll, uiDll] = await Promise.all([\n    bundleSize(buildDir, 'main', iframe, index),\n    bundleSize(buildDir, 'runtime', iframe, index),\n    bundleSize(buildDir, 'vendors', iframe, index),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_docs_dll.js')),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_ui_dll.js')),\n  ]);\n\n  return {\n    manager: {\n      total: main.manager + runtime.manager + vendors.manager,\n      main: main.manager,\n      runtime: runtime.manager,\n      vendors: vendors.manager,\n      uiDll,\n    },\n    preview: {\n      total: main.preview + runtime.preview + vendors.preview,\n      main: main.preview,\n      runtime: runtime.preview,\n      vendors: vendors.preview,\n      docsDll,\n    },\n  };\n};\n\nexport const cleanup = async () => {\n  rimraf.sync(BUILD_DIR);\n};\n\nexport const buildBrowseStorybook = async (extraFlags: string[]) => {\n  console.log('measuring build-storybook');\n\n  Tick.wrap(function build(done: () => void) {\n    spawnSync('yarn', ['build-storybook', ...extraFlags], { stdio: STDIO });\n    done();\n  });\n\n  let resolve: any;\n  const promise = new Promise((res: any) => {\n    resolve = res;\n  });\n\n  const stats = resetStats();\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  const staticServer = await makeStaticServer();\n\n  let statsServer: any;\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('resolving browse');\n    resolve();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('stopping static server');\n    await staticServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  const page = await browser.newPage();\n  await page.goto(`http://127.0.0.1:${STATIC_STORYBOOK_PORT}/index.html`);\n\n  await promise;\n\n  const build = {\n    time: {\n      build: timers.build.duration(),\n    },\n    size: {},\n  };\n\n  const bundles = await bundleSizes(BUILD_DIR);\n  const browse = {\n    size: {\n      total: await du(BUILD_DIR),\n      ...bundles,\n    },\n    time: stats.time,\n  };\n\n  return { build, browse };\n};\n","import fs from 'fs';\nimport { sync as spawnSync } from 'cross-spawn';\n\nconst ADDONS_REGEX = /(addons.*\\:.*\\[)/g;\nconst STDIO = 'inherit';\n\nconst insertAddonBench = (main: string) => {\n  const lines = main.split('\\n');\n  const updated = lines.map(line =>\n    line.replace(ADDONS_REGEX, '$1 \"@storybook/addon-bench\",')\n  );\n  return updated.join('\\n');\n};\n\nexport const installAddonBench = async () => {\n  let commandArgs = ['add', '@storybook/addon-bench', '--dev'];\n  if (isUsingYarn1()) {\n    commandArgs.push('-W');\n  }\n  spawnSync('yarn', commandArgs, {\n    stdio: STDIO,\n  });\n  const mainFile = '.storybook/main.js';\n  const main = fs.readFileSync(mainFile).toString();\n  if (!main.includes('@storybook/addon-bench')) {\n    const mainWithBench = insertAddonBench(main);\n    fs.writeFileSync(mainFile, mainWithBench);\n  }\n};\n\nconst isUsingYarn1 = (): boolean => {\n  const yarnVersionCommand = spawnSync('yarn', ['--version']);\n\n  if (yarnVersionCommand.status !== 0) {\n    throw new Error(`ðŸ§¶ Yarn must be installed to run '@storybook/bench'`);\n  }\n\n  const yarnVersion = yarnVersionCommand.output\n    .toString()\n    .replace(/,/g, '')\n    .replace(/\"/g, '');\n\n  return /^1\\.+/.test(yarnVersion);\n};\n","import { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport { Tick, timers } from 'exectimer';\nimport { installAddonBench } from './installAddonBench';\n\nconst NODE_MODULES = 'node_modules';\nconst STDIO = 'inherit';\n\nexport const installStorybook = async (installCommand: string) => {\n  console.log('measuring install');\n  if (!installCommand) {\n    console.warn('No install command provided');\n    return {\n      size: { total: 0 },\n      time: { total: 0 },\n    };\n  }\n\n  const initialSize = await du(NODE_MODULES);\n  Tick.wrap(function install(done: () => void) {\n    const [cmd, ...args] = installCommand.split(' ');\n    spawnSync(cmd, args, { stdio: STDIO });\n    done();\n  });\n  const finalSize = await du(NODE_MODULES);\n\n  // Add instrumentation addon AFTER we've measured install size\n  await installAddonBench();\n\n  return {\n    size: { total: finalSize - initialSize },\n    time: { total: timers.install.duration() },\n  };\n};\n","import { spawn } from 'cross-spawn';\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport Hapi from '@hapi/hapi';\nimport puppeteer from 'puppeteer';\n\nconst MANAGER_PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for manager and (\\d*\\.?\\d*) s for preview/gm;\nconst PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for preview/gm;\nconst DEV_PORT = 9999;\n\nconst logger = console;\n\nexport const startStorybook = async (extraFlags: string[]) => {\n  console.log('measuring start-storybook');\n\n  let resolveBuild: any;\n  const buildFinished = new Promise((res: any) => {\n    resolveBuild = res;\n  });\n\n  let resolveRender: any;\n  const renderFinished = new Promise((res: any) => {\n    resolveRender = res;\n  });\n\n  const stats = resetStats();\n  const child = spawn(\n    'yarn',\n    ['start-storybook', '-p', DEV_PORT.toString(), '--ci', ...extraFlags],\n    {\n      stdio: 'pipe',\n    }\n  );\n\n  let managerWebpack = -1;\n  let previewWebpack = -1;\n  child.stdout.on('data', data => {\n    const output = data.toString();\n    //â”‚   8.42 s for manager and 8.86 s for preview       â”‚\n    let match = MANAGER_PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 1000000000 * parseFloat(match[1]);\n      previewWebpack = 1000000000 * parseFloat(match[2]);\n      resolveBuild();\n    }\n    //â”‚   8.86 s for preview       â”‚\n    match = PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 0;\n      previewWebpack = 1000000000 * parseFloat(match[1]);\n      resolveBuild();\n    }\n  });\n  child.on('exit', () => {\n    logger.log('closing start-storybook');\n    resolveRender();\n  });\n  let statsServer: Hapi.Server;\n\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('killing start-storybook');\n    child.kill();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  await buildFinished;\n\n  const page = await browser.newPage();\n  await page.goto(`http://localhost:${DEV_PORT}/index.html`);\n\n  await renderFinished;\n\n  const webpackStats = {\n    managerWebpack,\n    previewWebpack,\n  };\n\n  return {\n    time: {\n      ...webpackStats,\n      ...stats.time,\n    },\n    size: {},\n  };\n};\n","const GCP_CREDENTIALS = JSON.parse(process.env.GCP_CREDENTIALS || '{}');\nconst SB_BENCH_UPLOAD = process.env.SB_BENCH_UPLOAD === 'true';\nconst { CIRCLE_BRANCH, CIRCLE_SHA1 } = process.env;\n\nexport { SB_BENCH_UPLOAD, GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 };\n","import { BigQuery } from '@google-cloud/bigquery';\nimport { sync as spawnSync } from 'cross-spawn';\nimport { GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 } from './environment';\nimport fs from 'fs';\n\nconst _gitHelper = (args: string[]): string => {\n  const result = spawnSync('git', args, { stdio: 'pipe' });\n  if (result.error) {\n    throw result.error;\n  }\n  return result.output.join('\\n').trim();\n};\n\nconst gitBranch = () => _gitHelper(['rev-parse', '--abbrev-ref', 'HEAD']);\nconst gitCommit = () => _gitHelper(['rev-parse', 'HEAD']);\n\nexport const upload = async (\n  { install, start, build, browse }: any,\n  label: string\n) => {\n  console.log('uploading to label', label);\n\n  const row = {\n    branch: CIRCLE_BRANCH || gitBranch(),\n    commit: CIRCLE_SHA1 || gitCommit(),\n    timestamp: new Date().toISOString(),\n    label,\n    installTime: install.time.total,\n    installSize: install.size.total,\n    startManagerBuild: start.time.managerWebpack,\n    startPreviewBuild: start.time.previewWebpack,\n    startManagerRender: start.time.managerRender,\n    startPreviewRender: start.time.previewRender,\n    buildTime: build.time.build,\n    browseManagerRender: browse.time.managerRender,\n    browsePreviewRender: browse.time.previewRender,\n    browseSizeTotal: browse.size.total,\n    browseSizeManagerTotal: browse.size.manager.total,\n    browseSizeManagerVendors: browse.size.manager.vendors,\n    browseSizeManagerUiDll: browse.size.manager.uiDll,\n    browseSizePreviewTotal: browse.size.preview.total,\n    browseSizePreviewVendors: browse.size.preview.vendors,\n    browseSizePreviewDocsDll: browse.size.preview.docsDll,\n  };\n\n  const bigquery = new BigQuery({\n    projectId: GCP_CREDENTIALS.project_id,\n    credentials: GCP_CREDENTIALS,\n  });\n  const dataset = bigquery.dataset('benchmark_results');\n  const appTable = dataset.table('bench');\n\n  await appTable.insert([row]);\n};\n\nexport const main = async () => {\n  const results = JSON.parse(fs.readFileSync('./bench.json').toString());\n  try {\n    await upload(results, 'bench');\n  } catch (err) {\n    console.log(err);\n    (err.errors || []).map((sub: any) => console.log(sub));\n  }\n};\n","import mapValues from 'lodash/mapValues';\nimport prettyBytes from 'pretty-bytes';\n\nconst prettyTime = (duration: number) => (duration / 1000000000.0).toFixed(2);\n\nconst mapValuesDeep = (obj: any, formatFn: any): any =>\n  typeof obj === 'object'\n    ? mapValues(obj, val => mapValuesDeep(val, formatFn))\n    : formatFn(obj);\n\nexport const formatString = (result: Record<string, any>) => ({\n  time: mapValuesDeep(result.time, prettyTime),\n  size: mapValuesDeep(result.size, prettyBytes),\n});\n\nconst toMS = (val: number) => Math.round(val / 1000000);\nconst toKB = (val: number) => Math.round(val / 1024);\n\nexport const formatNumber = (result: Record<string, any>) =>\n  mapValues(result, val => ({\n    time: mapValuesDeep(val.time, toMS),\n    size: mapValuesDeep(val.size, toKB),\n  }));\n","import jsonexport from 'jsonexport';\nimport program from 'commander';\nimport fs from 'fs';\n\nimport { cleanup, buildBrowseStorybook } from './buildBrowseStorybook';\nimport { installStorybook } from './installStorybook';\nimport { startStorybook } from './startStorybook';\n\nimport { upload } from './upload';\nimport { formatNumber } from './helpers/format';\nimport { SB_BENCH_UPLOAD } from './environment';\n\nconst stub = (arg?: any) => ({ time: {}, size: {} });\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst save = async (results: Record<string, any>, label: string) => {\n  const csv = await jsonexport(results);\n  fs.writeFileSync(`${label}.csv`, csv);\n  fs.writeFileSync(`${label}.json`, JSON.stringify(results));\n};\n\ninterface Options {\n  installCommand: string;\n  label: string;\n  extraFlags: string[];\n  benchmarks: {\n    install: boolean;\n    start: boolean;\n    browse: boolean;\n  };\n}\n\nconst benchmark = async ({\n  installCommand,\n  label,\n  extraFlags,\n  benchmarks,\n}: Options) => {\n  await cleanup();\n\n  const install = benchmarks.install\n    ? await installStorybook(installCommand)\n    : {};\n  const start = benchmarks.start ? await startStorybook(extraFlags) : {};\n  const browse = benchmarks.browse\n    ? await buildBrowseStorybook(extraFlags)\n    : { build: {}, browse: {} };\n\n  const bench = formatNumber({ install, start, ...browse });\n  await save(bench, label);\n\n  return bench;\n};\n\nexport const main = async () => {\n  program.arguments('[installCommand]');\n  program.option(\n    '-l, --label <label>',\n    'Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true',\n    'bench'\n  );\n  program.option(\n    '-e, --extra-flags <flags>',\n    'Run storybook with extra flags (e.g. \"--no-dll\")',\n    ''\n  );\n  program.option('--no-install', 'Do not measure storybook install time');\n  program.option('--no-start', 'Do not measure storybook start time');\n  program.option('--no-browse', 'Do not measure storybook browse time');\n  program.parse(process.argv);\n  if (program.install && !program.args.length) {\n    program.help();\n  }\n\n  const { label, extraFlags, install, start, browse } = program;\n  const installCommand = program.args[0];\n  const flags = extraFlags.length > 0 ? extraFlags.split(' ') : [];\n\n  const bench = await benchmark({\n    installCommand,\n    label,\n    extraFlags: flags,\n    benchmarks: {\n      install,\n      start,\n      browse,\n    },\n  });\n  if (SB_BENCH_UPLOAD) {\n    await upload(bench, label);\n  }\n};\n"],"names":["EVENTS","STATS_PORT","puppeteerArgs","now","Date","getTime","resetStats","stats","result","init","time","forEach","evt","makeStatsServer","done","server","Hapi","Server","port","addEvent","event","route","method","path","handler","req","h","console","log","response","code","start","STATIC_STORYBOOK_PORT","makeStaticServer","register","Inert","filePath","join","process","cwd","file","confine","info","uri","STDIO","BUILD_DIR","SCRIPT_REGEX","logger","getScripts","html","Array","from","matchAll","map","m","bundleSize","buildDir","prefix","iframeScripts","indexScripts","preview","find","f","startsWith","manager","Error","du","safeDu","bundleSizes","iframe","fs","readFileSync","toString","index","Promise","all","main","runtime","vendors","docsDll","uiDll","total","cleanup","rimraf","sync","buildBrowseStorybook","extraFlags","Tick","wrap","build","spawnSync","stdio","resolve","promise","res","puppeteer","launch","args","browser","staticServer","statsServer","stop","close","newPage","page","timers","duration","size","bundles","browse","ADDONS_REGEX","insertAddonBench","lines","split","updated","line","replace","installAddonBench","commandArgs","isUsingYarn1","push","mainFile","includes","mainWithBench","writeFileSync","yarnVersionCommand","status","yarnVersion","output","test","NODE_MODULES","installStorybook","installCommand","warn","initialSize","install","cmd","finalSize","MANAGER_PREVIEW_REGEX","PREVIEW_REGEX","DEV_PORT","startStorybook","resolveBuild","buildFinished","resolveRender","renderFinished","child","spawn","managerWebpack","previewWebpack","stdout","on","data","match","exec","parseFloat","kill","webpackStats","GCP_CREDENTIALS","JSON","parse","env","SB_BENCH_UPLOAD","CIRCLE_BRANCH","CIRCLE_SHA1","_gitHelper","error","trim","gitBranch","gitCommit","upload","label","row","branch","commit","timestamp","toISOString","installTime","installSize","startManagerBuild","startPreviewBuild","startManagerRender","managerRender","startPreviewRender","previewRender","buildTime","browseManagerRender","browsePreviewRender","browseSizeTotal","browseSizeManagerTotal","browseSizeManagerVendors","browseSizeManagerUiDll","browseSizePreviewTotal","browseSizePreviewVendors","browseSizePreviewDocsDll","bigquery","BigQuery","projectId","project_id","credentials","dataset","appTable","table","insert","mapValuesDeep","obj","formatFn","mapValues","val","toMS","Math","round","toKB","formatNumber","save","results","jsonexport","csv","stringify","benchmark","benchmarks","bench","program","arguments","option","argv","length","help","flags"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"bench.cjs.development.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/helpers/timing.ts","../src/helpers/static.ts","../src/buildBrowseStorybook.ts","../src/installAddonBench.ts","../src/installStorybook.ts","../src/startStorybook.ts","../src/environment.ts","../src/upload.ts","../src/helpers/format.ts","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import Hapi from '@hapi/hapi';\n\nexport const EVENTS = ['managerRender', 'previewRender', 'storyRender'];\nexport const STATS_PORT = 9898;\n\nexport type Stats = {\n  init: number;\n  time: Record<string, number | null>;\n};\n\nexport const puppeteerArgs = ['--no-sandbox', '--disable-setuid-sandbox'];\n\nconst now = () => new Date().getTime();\n\nexport const resetStats = (stats?: Stats) => {\n  const result = stats || ({ init: now(), time: {} } as Stats);\n  result.init = now();\n  EVENTS.forEach(evt => (result.time[evt] = null));\n  return result;\n};\n\nexport const makeStatsServer = async (stats: Stats, done: any) => {\n  const server = new Hapi.Server({ port: STATS_PORT });\n\n  const addEvent = (event: string) => {\n    server.route({\n      method: 'GET',\n      path: `/${event}`,\n      handler: async (req: any, h: any) => {\n        console.log(`HANDLER: ${event}`, stats);\n        if (!stats.time[event]) {\n          stats.time[event] = (now() - stats.init) * 1000000;\n        }\n        if (event === 'storyRender') {\n          done();\n        }\n        return h.response('ok').code(200);\n      },\n    });\n  };\n\n  EVENTS.forEach(evt => addEvent(evt));\n  await server.start();\n  return server;\n};\n","import Hapi from '@hapi/hapi';\nimport Inert from '@hapi/inert';\nimport path from 'path';\n\nexport const STATIC_STORYBOOK_PORT = 9899;\n\nexport const makeStaticServer = async () => {\n  const server = new Hapi.Server({\n    port: STATIC_STORYBOOK_PORT,\n  });\n  await server.register(Inert);\n\n  server.route({\n    method: 'GET',\n    path: '/{param*}',\n    handler: async (req, h) => {\n      const filePath = path.join(process.cwd(), 'storybook-static', req.path);\n      return h.file(filePath, { confine: false });\n    },\n  });\n\n  await server.start();\n  console.log('Static server:', server.info.uri);\n  return server;\n};\n","import { Tick, timers } from 'exectimer';\nimport { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport fs from 'fs';\nimport path from 'path';\nimport rimraf from 'rimraf';\nimport puppeteer from 'puppeteer';\n\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport { makeStaticServer, STATIC_STORYBOOK_PORT } from './helpers/static';\n\nconst STDIO = 'inherit';\nconst BUILD_DIR = 'storybook-static';\n\nconst SCRIPT_REGEX = /<script.*?src=\"(.[^\"]*\\.js)\">/g;\nconst logger = console;\n\nconst getScripts = (html: string) => {\n  // <script src=\"runtime~main.6a9b04192e3176eff72a.bundle.js\">\n  return Array.from(html.matchAll(SCRIPT_REGEX)).map(m => m[1]);\n};\n\nconst bundleSize = async (\n  buildDir: string,\n  prefix: string,\n  iframeScripts: string[],\n  indexScripts: string[]\n) => {\n  let preview = iframeScripts.find(f => f.startsWith(prefix));\n  let manager = indexScripts.find(f => f.startsWith(prefix));\n\n  // FIXME: webpack5 uses `290.d3d846e4d074e7386081.bundle.js`\n  if (prefix === 'vendors') {\n    manager =\n      manager ||\n      indexScripts.find(f => !f.startsWith('main') && !f.startsWith('runtime'));\n    preview =\n      preview ||\n      iframeScripts.find(\n        f => !f.startsWith('main') && !f.startsWith('runtime')\n      );\n  }\n\n  // FIXME: vite uses '/assets/iframe.d7d1f891.js`, no vendors or runtime\n  if (!preview && prefix === 'main') {\n    preview = iframeScripts.find(f => f.startsWith('/assets/iframe'));\n  }\n\n  if (!manager) {\n    throw new Error(`Missing manager files for '${prefix}')}`);\n  }\n\n  return {\n    manager: await du(path.join(buildDir, manager)),\n    preview: preview ? await du(path.join(buildDir, preview)) : 0,\n  };\n};\n\nconst safeDu = async (filePath: string) => {\n  try {\n    return await du(filePath);\n  } catch {\n    return 0;\n  }\n};\n\nexport const bundleSizes = async (buildDir: string) => {\n  const iframe = getScripts(\n    fs.readFileSync(path.join(buildDir, 'iframe.html')).toString()\n  );\n  const index = getScripts(\n    fs.readFileSync(path.join(buildDir, 'index.html')).toString()\n  );\n\n  const [main, runtime, vendors, docsDll, uiDll] = await Promise.all([\n    bundleSize(buildDir, 'main', iframe, index),\n    bundleSize(buildDir, 'runtime', iframe, index),\n    bundleSize(buildDir, 'vendors', iframe, index),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_docs_dll.js')),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_ui_dll.js')),\n  ]);\n\n  return {\n    manager: {\n      total: main.manager + runtime.manager + vendors.manager,\n      main: main.manager,\n      runtime: runtime.manager,\n      vendors: vendors.manager,\n      uiDll,\n    },\n    preview: {\n      total: main.preview + runtime.preview + vendors.preview,\n      main: main.preview,\n      runtime: runtime.preview,\n      vendors: vendors.preview,\n      docsDll,\n    },\n  };\n};\n\nexport const cleanup = async () => {\n  rimraf.sync(BUILD_DIR);\n};\n\nexport const buildBrowseStorybook = async (extraFlags: string[]) => {\n  console.log('measuring build-storybook');\n\n  Tick.wrap(function build(done: () => void) {\n    spawnSync('yarn', ['build-storybook', ...extraFlags], { stdio: STDIO });\n    done();\n  });\n\n  let resolve: any;\n  const promise = new Promise((res: any) => {\n    resolve = res;\n  });\n\n  const stats = resetStats();\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  const staticServer = await makeStaticServer();\n\n  let statsServer: any;\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('resolving browse');\n    resolve();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('stopping static server');\n    await staticServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  const page = await browser.newPage();\n  await page.goto(`http://127.0.0.1:${STATIC_STORYBOOK_PORT}/index.html`);\n\n  await promise;\n\n  const build = {\n    time: {\n      build: timers.build.duration(),\n    },\n    size: {},\n  };\n\n  const bundles = await bundleSizes(BUILD_DIR);\n  const browse = {\n    size: {\n      total: await du(BUILD_DIR),\n      ...bundles,\n    },\n    time: stats.time,\n  };\n\n  return { build, browse };\n};\n","import fs from 'fs';\nimport { sync as spawnSync } from 'cross-spawn';\n\nconst ADDONS_REGEX = /(addons.*\\:.*\\[)/g;\nconst STDIO = 'inherit';\n\nconst insertAddonBench = (main: string) => {\n  const lines = main.split('\\n');\n  const updated = lines.map(line =>\n    line.replace(ADDONS_REGEX, '$1 \"@storybook/addon-bench\",')\n  );\n  return updated.join('\\n');\n};\n\nexport const installAddonBench = async () => {\n  let commandArgs = ['add', '@storybook/addon-bench', '--dev'];\n  if (isUsingYarn1()) {\n    commandArgs.push('-W');\n  }\n  spawnSync('yarn', commandArgs, {\n    stdio: STDIO,\n  });\n  const mainFile = '.storybook/main.js';\n  const main = fs.readFileSync(mainFile).toString();\n  if (!main.includes('@storybook/addon-bench')) {\n    const mainWithBench = insertAddonBench(main);\n    fs.writeFileSync(mainFile, mainWithBench);\n  }\n};\n\nconst isUsingYarn1 = (): boolean => {\n  const yarnVersionCommand = spawnSync('yarn', ['--version']);\n\n  if (yarnVersionCommand.status !== 0) {\n    throw new Error(`ðŸ§¶ Yarn must be installed to run '@storybook/bench'`);\n  }\n\n  const yarnVersion = yarnVersionCommand.output\n    .toString()\n    .replace(/,/g, '')\n    .replace(/\"/g, '');\n\n  return /^1\\.+/.test(yarnVersion);\n};\n","import { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport { Tick, timers } from 'exectimer';\nimport { installAddonBench } from './installAddonBench';\n\nconst NODE_MODULES = 'node_modules';\nconst STDIO = 'inherit';\n\nexport const installStorybook = async (installCommand: string) => {\n  console.log('measuring install');\n  if (!installCommand) {\n    console.warn('No install command provided');\n    return {\n      size: { total: 0 },\n      time: { total: 0 },\n    };\n  }\n\n  const initialSize = await du(NODE_MODULES);\n  Tick.wrap(function install(done: () => void) {\n    const [cmd, ...args] = installCommand.split(' ');\n    spawnSync(cmd, args, { stdio: STDIO });\n    done();\n  });\n  const finalSize = await du(NODE_MODULES);\n\n  // Add instrumentation addon AFTER we've measured install size\n  await installAddonBench();\n\n  return {\n    size: { total: finalSize - initialSize },\n    time: { total: timers.install.duration() },\n  };\n};\n","import { spawn } from 'cross-spawn';\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport Hapi from '@hapi/hapi';\nimport puppeteer from 'puppeteer';\n\nconst MANAGER_PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for manager and (\\d*\\.?\\d*) s for preview/gm;\nconst PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for preview/gm;\nconst DEV_PORT = 9999;\n\nconst logger = console;\n\nexport const startStorybook = async (extraFlags: string[]) => {\n  console.log('measuring start-storybook');\n\n  let resolveBuild: any;\n  const buildFinished = new Promise((res: any) => {\n    resolveBuild = res;\n  });\n\n  let resolveRender: any;\n  const renderFinished = new Promise((res: any) => {\n    resolveRender = res;\n  });\n\n  const stats = resetStats();\n  const child = spawn(\n    'yarn',\n    ['start-storybook', '-p', DEV_PORT.toString(), '--ci', ...extraFlags],\n    {\n      stdio: 'pipe',\n    }\n  );\n\n  let managerWebpack = -1;\n  let previewWebpack = -1;\n  // Needed for webpack 4\n  // child.stderr.on('data', d => {\n  //   console.log(d.toString());\n  // });\n  child.stdout.on('data', data => {\n    const output = data.toString();\n    //â”‚   8.42 s for manager and 8.86 s for preview       â”‚\n    let match = MANAGER_PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 1000000000 * parseFloat(match[1]);\n      previewWebpack = 1000000000 * parseFloat(match[2]);\n      resolveBuild();\n    }\n    //â”‚   8.86 s for preview       â”‚\n    match = PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 0;\n      previewWebpack = 1000000000 * parseFloat(match[1]);\n      resolveBuild();\n    }\n  });\n  child.on('exit', () => {\n    logger.log('closing start-storybook');\n    resolveRender();\n  });\n  let statsServer: Hapi.Server;\n\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('killing start-storybook');\n    child.kill();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  await buildFinished;\n\n  const page = await browser.newPage();\n  await page.goto(`http://localhost:${DEV_PORT}`);\n  await renderFinished;\n\n  const webpackStats = {\n    managerWebpack,\n    previewWebpack,\n  };\n\n  return {\n    time: {\n      ...webpackStats,\n      ...stats.time,\n    },\n    size: {},\n  };\n};\n","const GCP_CREDENTIALS = JSON.parse(process.env.GCP_CREDENTIALS || '{}');\nconst SB_BENCH_UPLOAD = process.env.SB_BENCH_UPLOAD === 'true';\nconst { CIRCLE_BRANCH, CIRCLE_SHA1 } = process.env;\n\nexport { SB_BENCH_UPLOAD, GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 };\n","import { BigQuery } from '@google-cloud/bigquery';\nimport { sync as spawnSync } from 'cross-spawn';\nimport { GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 } from './environment';\nimport fs from 'fs';\n\nconst _gitHelper = (args: string[]): string => {\n  const result = spawnSync('git', args, { stdio: 'pipe' });\n  if (result.error) {\n    throw result.error;\n  }\n  return result.output.join('\\n').trim();\n};\n\nconst gitBranch = () => _gitHelper(['rev-parse', '--abbrev-ref', 'HEAD']);\nconst gitCommit = () => _gitHelper(['rev-parse', 'HEAD']);\n\nexport const upload = async (\n  { install, start, build, browse }: any,\n  label: string\n) => {\n  console.log('uploading to label', label);\n\n  const row = {\n    branch: CIRCLE_BRANCH || gitBranch(),\n    commit: CIRCLE_SHA1 || gitCommit(),\n    timestamp: new Date().toISOString(),\n    label,\n    installTime: install.time.total,\n    installSize: install.size.total,\n    startManagerBuild: start.time.managerWebpack,\n    startPreviewBuild: start.time.previewWebpack,\n    startManagerRender: start.time.managerRender,\n    startPreviewRender: start.time.previewRender,\n    buildTime: build.time.build,\n    browseManagerRender: browse.time.managerRender,\n    browsePreviewRender: browse.time.previewRender,\n    browseSizeTotal: browse.size.total,\n    browseSizeManagerTotal: browse.size.manager.total,\n    browseSizeManagerVendors: browse.size.manager.vendors,\n    browseSizeManagerUiDll: browse.size.manager.uiDll,\n    browseSizePreviewTotal: browse.size.preview.total,\n    browseSizePreviewVendors: browse.size.preview.vendors,\n    browseSizePreviewDocsDll: browse.size.preview.docsDll,\n  };\n\n  const bigquery = new BigQuery({\n    projectId: GCP_CREDENTIALS.project_id,\n    credentials: GCP_CREDENTIALS,\n  });\n  const dataset = bigquery.dataset('benchmark_results');\n  const appTable = dataset.table('bench');\n\n  await appTable.insert([row]);\n};\n\nexport const main = async () => {\n  const results = JSON.parse(fs.readFileSync('./bench.json').toString());\n  try {\n    await upload(results, 'bench');\n  } catch (err) {\n    console.log(err);\n    (err.errors || []).map((sub: any) => console.log(sub));\n  }\n};\n","import mapValues from 'lodash/mapValues';\nimport prettyBytes from 'pretty-bytes';\n\nconst prettyTime = (duration: number) => (duration / 1000000000.0).toFixed(2);\n\nconst mapValuesDeep = (obj: any, formatFn: any): any =>\n  typeof obj === 'object'\n    ? mapValues(obj, val => mapValuesDeep(val, formatFn))\n    : formatFn(obj);\n\nexport const formatString = (result: Record<string, any>) => ({\n  time: mapValuesDeep(result.time, prettyTime),\n  size: mapValuesDeep(result.size, prettyBytes),\n});\n\nconst toMS = (val: number) => Math.round(val / 1000000);\nconst toKB = (val: number) => Math.round(val / 1024);\n\nexport const formatNumber = (result: Record<string, any>) =>\n  mapValues(result, val => ({\n    time: mapValuesDeep(val.time, toMS),\n    size: mapValuesDeep(val.size, toKB),\n  }));\n","import jsonexport from 'jsonexport';\nimport program from 'commander';\nimport fs from 'fs';\n\nimport { cleanup, buildBrowseStorybook } from './buildBrowseStorybook';\nimport { installStorybook } from './installStorybook';\nimport { startStorybook } from './startStorybook';\n\nimport { upload } from './upload';\nimport { formatNumber } from './helpers/format';\nimport { SB_BENCH_UPLOAD } from './environment';\n\nconst stub = (arg?: any) => ({ time: {}, size: {} });\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst save = async (results: Record<string, any>, label: string) => {\n  const csv = await jsonexport(results);\n  fs.writeFileSync(`${label}.csv`, csv);\n  fs.writeFileSync(`${label}.json`, JSON.stringify(results));\n};\n\ninterface Options {\n  installCommand: string;\n  label: string;\n  extraFlags: string[];\n}\n\nconst benchmark = async ({ installCommand, label, extraFlags }: Options) => {\n  await cleanup();\n\n  const install = await installStorybook(installCommand);\n  const start = await startStorybook(extraFlags);\n  const { build, browse } = await buildBrowseStorybook(extraFlags);\n\n  const bench = formatNumber({ install, start, build, browse });\n  await save(bench, label);\n\n  return bench;\n};\n\nexport const main = async () => {\n  program.arguments('<installCommand>');\n  program.option(\n    '-l, --label <label>',\n    'Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true',\n    'bench'\n  );\n  program.option(\n    '-e, --extra-flags <flags>',\n    'Run storybook with extra flags (e.g. \"--no-dll\")',\n    ''\n  );\n  program.parse(process.argv);\n  if (!program.args.length) {\n    program.help();\n  }\n\n  const { label, extraFlags } = program;\n  const installCommand = program.args[0];\n  const flags = extraFlags.length > 0 ? extraFlags.split(' ') : [];\n\n  const bench = await benchmark({ installCommand, label, extraFlags: flags });\n  if (SB_BENCH_UPLOAD) {\n    await upload(bench, label);\n  }\n};\n"],"names":["EVENTS","STATS_PORT","puppeteerArgs","now","Date","getTime","resetStats","stats","result","init","time","forEach","evt","makeStatsServer","done","server","Hapi","Server","port","addEvent","event","route","method","path","handler","req","h","console","log","response","code","start","STATIC_STORYBOOK_PORT","makeStaticServer","register","Inert","filePath","join","process","cwd","file","confine","info","uri","STDIO","BUILD_DIR","SCRIPT_REGEX","logger","getScripts","html","Array","from","matchAll","map","m","bundleSize","buildDir","prefix","iframeScripts","indexScripts","preview","find","f","startsWith","manager","Error","du","safeDu","bundleSizes","iframe","fs","readFileSync","toString","index","Promise","all","main","runtime","vendors","docsDll","uiDll","total","cleanup","rimraf","sync","buildBrowseStorybook","extraFlags","Tick","wrap","build","spawnSync","stdio","resolve","promise","res","puppeteer","launch","args","browser","staticServer","statsServer","stop","close","newPage","page","timers","duration","size","bundles","browse","ADDONS_REGEX","insertAddonBench","lines","split","updated","line","replace","installAddonBench","commandArgs","isUsingYarn1","push","mainFile","includes","mainWithBench","writeFileSync","yarnVersionCommand","status","yarnVersion","output","test","NODE_MODULES","installStorybook","installCommand","warn","initialSize","install","cmd","finalSize","MANAGER_PREVIEW_REGEX","PREVIEW_REGEX","DEV_PORT","startStorybook","resolveBuild","buildFinished","resolveRender","renderFinished","child","spawn","managerWebpack","previewWebpack","stdout","on","data","match","exec","parseFloat","kill","webpackStats","GCP_CREDENTIALS","JSON","parse","env","SB_BENCH_UPLOAD","CIRCLE_BRANCH","CIRCLE_SHA1","_gitHelper","error","trim","gitBranch","gitCommit","upload","label","row","branch","commit","timestamp","toISOString","installTime","installSize","startManagerBuild","startPreviewBuild","startManagerRender","managerRender","startPreviewRender","previewRender","buildTime","browseManagerRender","browsePreviewRender","browseSizeTotal","browseSizeManagerTotal","browseSizeManagerVendors","browseSizeManagerUiDll","browseSizePreviewTotal","browseSizePreviewVendors","browseSizePreviewDocsDll","bigquery","BigQuery","projectId","project_id","credentials","dataset","appTable","table","insert","mapValuesDeep","obj","formatFn","mapValues","val","toMS","Math","round","toKB","formatNumber","save","results","jsonexport","csv","stringify","benchmark","bench","program","arguments","option","argv","length","help","flags"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/bench.cjs.production.min.js b/dist/bench.cjs.production.min.js
index 679f0c718262f9904f0c66b3326a34accc723427..4bf6716fa5d5315b02276e3aa600295ba10ee718 100644
--- a/dist/bench.cjs.production.min.js
+++ b/dist/bench.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var r=e(require("jsonexport")),t=e(require("commander")),n=e(require("fs")),o=require("exectimer"),i=require("cross-spawn"),s=e(require("du")),a=e(require("path")),u=e(require("rimraf")),l=e(require("puppeteer")),c=e(require("@hapi/hapi")),m=e(require("@hapi/inert")),f=require("@google-cloud/bigquery"),v=e(require("lodash/mapValues"));function d(){return(d=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}require("pretty-bytes"),"undefined"!=typeof Symbol&&(Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator"))),"undefined"!=typeof Symbol&&(Symbol.asyncIterator||(Symbol.asyncIterator=Symbol("Symbol.asyncIterator")));var h=["managerRender","previewRender"],p=["--no-sandbox","--disable-setuid-sandbox"],b=function(){return(new Date).getTime()},g=function(e){var r=e||{init:b(),time:{}};return r.init=b(),h.forEach((function(e){return r.time[e]=null})),r},y=function(e,r){try{var t=new c.Server({port:9898});return h.forEach((function(n){var o;t.route({method:"GET",path:"/"+(o=n),handler:function(t,n){try{return console.log("HANDLER: "+o,e),e.time[o]||(e.time[o]=1e6*(b()-e.init)),"previewRender"===o&&r(),Promise.resolve(n.response("ok").code(200))}catch(e){return Promise.reject(e)}}})})),Promise.resolve(t.start()).then((function(){return t}))}catch(e){return Promise.reject(e)}},P=/<script.*?src="(.[^"]*\.js)">/g,w=console,S=function(e){return Array.from(e.matchAll(P)).map((function(e){return e[1]}))},j=function(e,r,t,n){try{var o=t.find((function(e){return e.startsWith(r)})),i=n.find((function(e){return e.startsWith(r)}));if("vendors"===r&&(i=i||n.find((function(e){return!e.startsWith("main")&&!e.startsWith("runtime")})),o=o||t.find((function(e){return!e.startsWith("main")&&!e.startsWith("runtime")}))),o||"main"!==r||(o=t.find((function(e){return e.startsWith("/assets/iframe")}))),!i)throw new Error("Missing manager files for '"+r+"')}");return Promise.resolve(s(a.join(e,i))).then((function(r){function t(e){return{manager:r,preview:e}}return o?Promise.resolve(s(a.join(e,o))).then(t):t(0)}))}catch(e){return Promise.reject(e)}},k=function(e){return Promise.resolve(function(r,t){try{var n=Promise.resolve(s(e))}catch(e){return 0}return n&&n.then?n.then(void 0,(function(){return 0})):n}())},z=/(addons.*\:.*\[)/g,_=/^.\s+(\d*\.?\d*) s for manager and (\d*\.?\d*) s for preview/gm,D=/^.\s+(\d*\.?\d*) s for preview/gm,x=console,R=JSON.parse(process.env.GCP_CREDENTIALS||"{}"),q="true"===process.env.SB_BENCH_UPLOAD,E=process.env,C=E.CIRCLE_BRANCH,F=E.CIRCLE_SHA1,W=function(e){var r=i.sync("git",e,{stdio:"pipe"});if(r.error)throw r.error;return r.output.join("\n").trim()},T=function e(r,t){return"object"==typeof r?v(r,(function(r){return e(r,t)})):t(r)},A=function(e){return Math.round(e/1e6)},M=function(e){return Math.round(e/1024)};exports.main=function(){try{t.arguments("[installCommand]"),t.option("-l, --label <label>","Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true","bench"),t.option("-e, --extra-flags <flags>",'Run storybook with extra flags (e.g. "--no-dll")',""),t.option("--no-install","Do not measure storybook install time"),t.option("--no-start","Do not measure storybook start time"),t.option("--no-browse","Do not measure storybook browse time"),t.parse(process.argv),t.install&&!t.args.length&&t.help();var e=t.label,h=t.extraFlags,b=t.install,P=t.start,E=t.browse,O=t.args[0],B=h.length>0?h.split(" "):[];return Promise.resolve(function(e){var t=e.installCommand,f=e.label,h=e.extraFlags,b=e.benchmarks;try{return Promise.resolve(function(){try{return u.sync("storybook-static"),Promise.resolve()}catch(e){return Promise.reject(e)}}()).then((function(){function e(e){function t(t){function u(o){var i,s=(i=d({install:e,start:t},o),v(i,(function(e){return{time:T(e.time,A),size:T(e.size,M)}})));return Promise.resolve(function(e,t){try{return Promise.resolve(r(e)).then((function(r){n.writeFileSync(t+".csv",r),n.writeFileSync(t+".json",JSON.stringify(e))}))}catch(e){return Promise.reject(e)}}(s,f)).then((function(){return s}))}return b.browse?Promise.resolve(function(e){try{var r;console.log("measuring build-storybook"),o.Tick.wrap((function(r){i.sync("yarn",["build-storybook"].concat(e),{stdio:"inherit"}),r()}));var t=new Promise((function(e){r=e})),u=g();return Promise.resolve(l.launch({args:p})).then((function(e){return Promise.resolve(function(){try{var e=new c.Server({port:9899});return Promise.resolve(e.register(m)).then((function(){return e.route({method:"GET",path:"/{param*}",handler:function(e,r){try{var t=a.join(process.cwd(),"storybook-static",e.path);return Promise.resolve(r.file(t,{confine:!1}))}catch(e){return Promise.reject(e)}}}),Promise.resolve(e.start()).then((function(){return console.log("Static server:",e.info.uri),e}))}))}catch(e){return Promise.reject(e)}}()).then((function(i){var l;return Promise.resolve(y(u,(function(){try{return w.log("resolving browse"),r(),w.log("stopping stats server"),Promise.resolve(l.stop()).then((function(){return w.log("stopping static server"),Promise.resolve(i.stop()).then((function(){return w.log("closing puppeteer"),Promise.resolve(e.close()).then((function(){}))}))}))}catch(e){return Promise.reject(e)}}))).then((function(r){return l=r,Promise.resolve(e.newPage()).then((function(e){return Promise.resolve(e.goto("http://127.0.0.1:9899/index.html")).then((function(){return Promise.resolve(t).then((function(){var e={time:{build:o.timers.build.duration()},size:{}};return Promise.resolve(function(e){try{var r=S(n.readFileSync(a.join(e,"iframe.html")).toString()),t=S(n.readFileSync(a.join(e,"index.html")).toString());return Promise.resolve(Promise.all([j(e,"main",r,t),j(e,"runtime",r,t),j(e,"vendors",r,t),k(a.join(e,"sb_dll","storybook_docs_dll.js")),k(a.join(e,"sb_dll","storybook_ui_dll.js"))])).then((function(e){var r=e[0],t=e[1],n=e[2];return{manager:{total:r.manager+t.manager+n.manager,main:r.manager,runtime:t.manager,vendors:n.manager,uiDll:e[4]},preview:{total:r.preview+t.preview+n.preview,main:r.preview,runtime:t.preview,vendors:n.preview,docsDll:e[3]}}}))}catch(e){return Promise.reject(e)}}("storybook-static")).then((function(r){return Promise.resolve(s("storybook-static")).then((function(t){var n={size:d({total:t},r),time:u.time};return{build:e,browse:n}}))}))}))}))}))}))}))}))}catch(e){return Promise.reject(e)}}(h)).then(u):u({build:{},browse:{}})}return b.start?Promise.resolve(function(e){try{var r;console.log("measuring start-storybook");var t,n,o=new Promise((function(e){r=e})),s=new Promise((function(e){t=e})),a=g(),u=i.spawn("yarn",["start-storybook","-p",9999..toString(),"--ci"].concat(e),{stdio:"pipe"}),c=-1,m=-1;return u.stdout.on("data",(function(e){var t=e.toString(),n=_.exec(t);n&&(console.log({match:n}),c=1e9*parseFloat(n[1]),m=1e9*parseFloat(n[2]),r()),(n=D.exec(t))&&(console.log({match:n}),c=0,m=1e9*parseFloat(n[1]),r())})),u.on("exit",(function(){x.log("closing start-storybook"),t()})),Promise.resolve(l.launch({args:p})).then((function(e){return Promise.resolve(y(a,(function(){try{return x.log("killing start-storybook"),u.kill(),x.log("stopping stats server"),Promise.resolve(n.stop()).then((function(){return x.log("closing puppeteer"),Promise.resolve(e.close()).then((function(){}))}))}catch(e){return Promise.reject(e)}}))).then((function(r){return n=r,Promise.resolve(o).then((function(){return Promise.resolve(e.newPage()).then((function(e){return Promise.resolve(e.goto("http://localhost:9999/index.html")).then((function(){return Promise.resolve(s).then((function(){return{time:d({},{managerWebpack:c,previewWebpack:m},a.time),size:{}}}))}))}))}))}))}))}catch(e){return Promise.reject(e)}}(h)).then(t):t({})}return b.install?Promise.resolve(function(e){try{return console.log("measuring install"),e?Promise.resolve(s("node_modules")).then((function(r){return o.Tick.wrap((function(r){var t=e.split(" "),n=t[0],o=t.slice(1);i.sync(n,o,{stdio:"inherit"}),r()})),Promise.resolve(s("node_modules")).then((function(e){return Promise.resolve(function(){try{var e=["add","@storybook/addon-bench","--dev"];(function(){var e=i.sync("yarn",["--version"]);if(0!==e.status)throw new Error("ðŸ§¶ Yarn must be installed to run '@storybook/bench'");var r=e.output.toString().replace(/,/g,"").replace(/"/g,"");return/^1\.+/.test(r)})()&&e.push("-W"),i.sync("yarn",e,{stdio:"inherit"});var r=n.readFileSync(".storybook/main.js").toString();if(!r.includes("@storybook/addon-bench")){var t=function(e){return e.split("\n").map((function(e){return e.replace(z,'$1 "@storybook/addon-bench",')})).join("\n")}(r);n.writeFileSync(".storybook/main.js",t)}return Promise.resolve()}catch(e){return Promise.reject(e)}}()).then((function(){return{size:{total:e-r},time:{total:o.timers.install.duration()}}}))}))})):(console.warn("No install command provided"),Promise.resolve({size:{total:0},time:{total:0}}))}catch(e){return Promise.reject(e)}}(t)).then(e):e({})}))}catch(e){return Promise.reject(e)}}({installCommand:O,label:e,extraFlags:B,benchmarks:{install:b,start:P,browse:E}})).then((function(r){var t=function(){if(q)return Promise.resolve(function(e,r){var t=e.install,n=e.start,o=e.build,i=e.browse;try{console.log("uploading to label",r);var s={branch:C||W(["rev-parse","--abbrev-ref","HEAD"]),commit:F||W(["rev-parse","HEAD"]),timestamp:(new Date).toISOString(),label:r,installTime:t.time.total,installSize:t.size.total,startManagerBuild:n.time.managerWebpack,startPreviewBuild:n.time.previewWebpack,startManagerRender:n.time.managerRender,startPreviewRender:n.time.previewRender,buildTime:o.time.build,browseManagerRender:i.time.managerRender,browsePreviewRender:i.time.previewRender,browseSizeTotal:i.size.total,browseSizeManagerTotal:i.size.manager.total,browseSizeManagerVendors:i.size.manager.vendors,browseSizeManagerUiDll:i.size.manager.uiDll,browseSizePreviewTotal:i.size.preview.total,browseSizePreviewVendors:i.size.preview.vendors,browseSizePreviewDocsDll:i.size.preview.docsDll},a=new f.BigQuery({projectId:R.project_id,credentials:R}).dataset("benchmark_results").table("bench");return Promise.resolve(a.insert([s])).then((function(){}))}catch(e){return Promise.reject(e)}}(r,e)).then((function(){}))}();if(t&&t.then)return t.then((function(){}))}))}catch(e){return Promise.reject(e)}};
+"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var r=e(require("jsonexport")),t=e(require("commander")),n=e(require("fs")),o=require("exectimer"),i=require("cross-spawn"),s=e(require("du")),a=e(require("path")),u=e(require("rimraf")),c=e(require("puppeteer")),l=e(require("@hapi/hapi")),m=e(require("@hapi/inert")),f=require("@google-cloud/bigquery"),v=e(require("lodash/mapValues"));function d(){return(d=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}require("pretty-bytes"),"undefined"!=typeof Symbol&&(Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator"))),"undefined"!=typeof Symbol&&(Symbol.asyncIterator||(Symbol.asyncIterator=Symbol("Symbol.asyncIterator")));var h=["managerRender","previewRender","storyRender"],p=["--no-sandbox","--disable-setuid-sandbox"],g=function(){return(new Date).getTime()},b=function(e){var r=e||{init:g(),time:{}};return r.init=g(),h.forEach((function(e){return r.time[e]=null})),r},y=function(e,r){try{var t=new l.Server({port:9898});return h.forEach((function(n){var o;t.route({method:"GET",path:"/"+(o=n),handler:function(t,n){try{return console.log("HANDLER: "+o,e),e.time[o]||(e.time[o]=1e6*(g()-e.init)),"storyRender"===o&&r(),Promise.resolve(n.response("ok").code(200))}catch(e){return Promise.reject(e)}}})})),Promise.resolve(t.start()).then((function(){return t}))}catch(e){return Promise.reject(e)}},P=/<script.*?src="(.[^"]*\.js)">/g,w=console,S=function(e){return Array.from(e.matchAll(P)).map((function(e){return e[1]}))},j=function(e,r,t,n){try{var o=t.find((function(e){return e.startsWith(r)})),i=n.find((function(e){return e.startsWith(r)}));if("vendors"===r&&(i=i||n.find((function(e){return!e.startsWith("main")&&!e.startsWith("runtime")})),o=o||t.find((function(e){return!e.startsWith("main")&&!e.startsWith("runtime")}))),o||"main"!==r||(o=t.find((function(e){return e.startsWith("/assets/iframe")}))),!i)throw new Error("Missing manager files for '"+r+"')}");return Promise.resolve(s(a.join(e,i))).then((function(r){function t(e){return{manager:r,preview:e}}return o?Promise.resolve(s(a.join(e,o))).then(t):t(0)}))}catch(e){return Promise.reject(e)}},k=function(e){return Promise.resolve(function(r,t){try{var n=Promise.resolve(s(e))}catch(e){return 0}return n&&n.then?n.then(void 0,(function(){return 0})):n}())},z=/(addons.*\:.*\[)/g,_=/^.\s+(\d*\.?\d*) s for manager and (\d*\.?\d*) s for preview/gm,R=/^.\s+(\d*\.?\d*) s for preview/gm,x=console,q=JSON.parse(process.env.GCP_CREDENTIALS||"{}"),D="true"===process.env.SB_BENCH_UPLOAD,E=process.env,C=E.CIRCLE_BRANCH,F=E.CIRCLE_SHA1,W=function(e){var r=i.sync("git",e,{stdio:"pipe"});if(r.error)throw r.error;return r.output.join("\n").trim()},T=function e(r,t){return"object"==typeof r?v(r,(function(r){return e(r,t)})):t(r)},A=function(e){return Math.round(e/1e6)},M=function(e){return Math.round(e/1024)};exports.main=function(){try{t.arguments("<installCommand>"),t.option("-l, --label <label>","Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true","bench"),t.option("-e, --extra-flags <flags>",'Run storybook with extra flags (e.g. "--no-dll")',""),t.parse(process.argv),t.args.length||t.help();var e=t.label,h=t.extraFlags,g=t.args[0],P=h.length>0?h.split(" "):[];return Promise.resolve(function(e){var t=e.installCommand,f=e.label,h=e.extraFlags;try{return Promise.resolve(function(){try{return u.sync("storybook-static"),Promise.resolve()}catch(e){return Promise.reject(e)}}()).then((function(){return Promise.resolve(function(e){try{return console.log("measuring install"),e?Promise.resolve(s("node_modules")).then((function(r){return o.Tick.wrap((function(r){var t=e.split(" "),n=t[0],o=t.slice(1);i.sync(n,o,{stdio:"inherit"}),r()})),Promise.resolve(s("node_modules")).then((function(e){return Promise.resolve(function(){try{var e=["add","@storybook/addon-bench","--dev"];(function(){var e=i.sync("yarn",["--version"]);if(0!==e.status)throw new Error("ðŸ§¶ Yarn must be installed to run '@storybook/bench'");var r=e.output.toString().replace(/,/g,"").replace(/"/g,"");return/^1\.+/.test(r)})()&&e.push("-W"),i.sync("yarn",e,{stdio:"inherit"});var r=n.readFileSync(".storybook/main.js").toString();if(!r.includes("@storybook/addon-bench")){var t=function(e){return e.split("\n").map((function(e){return e.replace(z,'$1 "@storybook/addon-bench",')})).join("\n")}(r);n.writeFileSync(".storybook/main.js",t)}return Promise.resolve()}catch(e){return Promise.reject(e)}}()).then((function(){return{size:{total:e-r},time:{total:o.timers.install.duration()}}}))}))})):(console.warn("No install command provided"),Promise.resolve({size:{total:0},time:{total:0}}))}catch(e){return Promise.reject(e)}}(t)).then((function(e){return Promise.resolve(function(e){try{var r;console.log("measuring start-storybook");var t,n,o=new Promise((function(e){r=e})),s=new Promise((function(e){t=e})),a=b(),u=i.spawn("yarn",["start-storybook","-p",9999..toString(),"--ci"].concat(e),{stdio:"pipe"}),l=-1,m=-1;return u.stdout.on("data",(function(e){var t=e.toString(),n=_.exec(t);n&&(console.log({match:n}),l=1e9*parseFloat(n[1]),m=1e9*parseFloat(n[2]),r()),(n=R.exec(t))&&(console.log({match:n}),l=0,m=1e9*parseFloat(n[1]),r())})),u.on("exit",(function(){x.log("closing start-storybook"),t()})),Promise.resolve(c.launch({args:p})).then((function(e){return Promise.resolve(y(a,(function(){try{return x.log("killing start-storybook"),u.kill(),x.log("stopping stats server"),Promise.resolve(n.stop()).then((function(){return x.log("closing puppeteer"),Promise.resolve(e.close()).then((function(){}))}))}catch(e){return Promise.reject(e)}}))).then((function(r){return n=r,Promise.resolve(o).then((function(){return Promise.resolve(e.newPage()).then((function(e){return Promise.resolve(e.goto("http://localhost:9999")).then((function(){return Promise.resolve(s).then((function(){return{time:d({},{managerWebpack:l,previewWebpack:m},a.time),size:{}}}))}))}))}))}))}))}catch(e){return Promise.reject(e)}}(h)).then((function(t){return Promise.resolve(function(e){try{var r;console.log("measuring build-storybook"),o.Tick.wrap((function(r){i.sync("yarn",["build-storybook"].concat(e),{stdio:"inherit"}),r()}));var t=new Promise((function(e){r=e})),u=b();return Promise.resolve(c.launch({args:p})).then((function(e){return Promise.resolve(function(){try{var e=new l.Server({port:9899});return Promise.resolve(e.register(m)).then((function(){return e.route({method:"GET",path:"/{param*}",handler:function(e,r){try{var t=a.join(process.cwd(),"storybook-static",e.path);return Promise.resolve(r.file(t,{confine:!1}))}catch(e){return Promise.reject(e)}}}),Promise.resolve(e.start()).then((function(){return console.log("Static server:",e.info.uri),e}))}))}catch(e){return Promise.reject(e)}}()).then((function(i){var c;return Promise.resolve(y(u,(function(){try{return w.log("resolving browse"),r(),w.log("stopping stats server"),Promise.resolve(c.stop()).then((function(){return w.log("stopping static server"),Promise.resolve(i.stop()).then((function(){return w.log("closing puppeteer"),Promise.resolve(e.close()).then((function(){}))}))}))}catch(e){return Promise.reject(e)}}))).then((function(r){return c=r,Promise.resolve(e.newPage()).then((function(e){return Promise.resolve(e.goto("http://127.0.0.1:9899/index.html")).then((function(){return Promise.resolve(t).then((function(){var e={time:{build:o.timers.build.duration()},size:{}};return Promise.resolve(function(e){try{var r=S(n.readFileSync(a.join(e,"iframe.html")).toString()),t=S(n.readFileSync(a.join(e,"index.html")).toString());return Promise.resolve(Promise.all([j(e,"main",r,t),j(e,"runtime",r,t),j(e,"vendors",r,t),k(a.join(e,"sb_dll","storybook_docs_dll.js")),k(a.join(e,"sb_dll","storybook_ui_dll.js"))])).then((function(e){var r=e[0],t=e[1],n=e[2];return{manager:{total:r.manager+t.manager+n.manager,main:r.manager,runtime:t.manager,vendors:n.manager,uiDll:e[4]},preview:{total:r.preview+t.preview+n.preview,main:r.preview,runtime:t.preview,vendors:n.preview,docsDll:e[3]}}}))}catch(e){return Promise.reject(e)}}("storybook-static")).then((function(r){return Promise.resolve(s("storybook-static")).then((function(t){var n={size:d({total:t},r),time:u.time};return{build:e,browse:n}}))}))}))}))}))}))}))}))}catch(e){return Promise.reject(e)}}(h)).then((function(o){var i=v({install:e,start:t,build:o.build,browse:o.browse},(function(e){return{time:T(e.time,A),size:T(e.size,M)}}));return Promise.resolve(function(e,t){try{return Promise.resolve(r(e)).then((function(r){n.writeFileSync(t+".csv",r),n.writeFileSync(t+".json",JSON.stringify(e))}))}catch(e){return Promise.reject(e)}}(i,f)).then((function(){return i}))}))}))}))}))}catch(e){return Promise.reject(e)}}({installCommand:g,label:e,extraFlags:P})).then((function(r){var t=function(){if(D)return Promise.resolve(function(e,r){var t=e.install,n=e.start,o=e.build,i=e.browse;try{console.log("uploading to label",r);var s={branch:C||W(["rev-parse","--abbrev-ref","HEAD"]),commit:F||W(["rev-parse","HEAD"]),timestamp:(new Date).toISOString(),label:r,installTime:t.time.total,installSize:t.size.total,startManagerBuild:n.time.managerWebpack,startPreviewBuild:n.time.previewWebpack,startManagerRender:n.time.managerRender,startPreviewRender:n.time.previewRender,buildTime:o.time.build,browseManagerRender:i.time.managerRender,browsePreviewRender:i.time.previewRender,browseSizeTotal:i.size.total,browseSizeManagerTotal:i.size.manager.total,browseSizeManagerVendors:i.size.manager.vendors,browseSizeManagerUiDll:i.size.manager.uiDll,browseSizePreviewTotal:i.size.preview.total,browseSizePreviewVendors:i.size.preview.vendors,browseSizePreviewDocsDll:i.size.preview.docsDll},a=new f.BigQuery({projectId:q.project_id,credentials:q}).dataset("benchmark_results").table("bench");return Promise.resolve(a.insert([s])).then((function(){}))}catch(e){return Promise.reject(e)}}(r,e)).then((function(){}))}();if(t&&t.then)return t.then((function(){}))}))}catch(e){return Promise.reject(e)}};
 //# sourceMappingURL=bench.cjs.production.min.js.map
diff --git a/dist/bench.cjs.production.min.js.map b/dist/bench.cjs.production.min.js.map
index 7a01425d945d6e81d710fcbfb05e261d06103c0e..cbb2b0fa26bd3833f203a42f8f397f16bff29b03 100644
--- a/dist/bench.cjs.production.min.js.map
+++ b/dist/bench.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"bench.cjs.production.min.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/helpers/timing.ts","../src/buildBrowseStorybook.ts","../src/installAddonBench.ts","../src/startStorybook.ts","../src/environment.ts","../src/upload.ts","../src/helpers/format.ts","../src/index.ts","../src/helpers/static.ts","../src/installStorybook.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import Hapi from '@hapi/hapi';\n\nexport const EVENTS = ['managerRender', 'previewRender']; // , 'storyRender'\nexport const STATS_PORT = 9898;\n\nexport type Stats = {\n  init: number;\n  time: Record<string, number | null>;\n};\n\nexport const puppeteerArgs = ['--no-sandbox', '--disable-setuid-sandbox'];\n\nconst now = () => new Date().getTime();\n\nexport const resetStats = (stats?: Stats) => {\n  const result = stats || ({ init: now(), time: {} } as Stats);\n  result.init = now();\n  EVENTS.forEach(evt => (result.time[evt] = null));\n  return result;\n};\n\nexport const makeStatsServer = async (stats: Stats, done: any) => {\n  const server = new Hapi.Server({ port: STATS_PORT });\n\n  const addEvent = (event: string) => {\n    server.route({\n      method: 'GET',\n      path: `/${event}`,\n      handler: async (req: any, h: any) => {\n        console.log(`HANDLER: ${event}`, stats);\n        if (!stats.time[event]) {\n          stats.time[event] = (now() - stats.init) * 1000000;\n        }\n        if (event === 'previewRender') {\n          done();\n        }\n        return h.response('ok').code(200);\n      },\n    });\n  };\n\n  EVENTS.forEach(evt => addEvent(evt));\n  await server.start();\n  return server;\n};\n","import { Tick, timers } from 'exectimer';\nimport { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport fs from 'fs';\nimport path from 'path';\nimport rimraf from 'rimraf';\nimport puppeteer from 'puppeteer';\n\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport { makeStaticServer, STATIC_STORYBOOK_PORT } from './helpers/static';\n\nconst STDIO = 'inherit';\nconst BUILD_DIR = 'storybook-static';\n\nconst SCRIPT_REGEX = /<script.*?src=\"(.[^\"]*\\.js)\">/g;\nconst logger = console;\n\nconst getScripts = (html: string) => {\n  // <script src=\"runtime~main.6a9b04192e3176eff72a.bundle.js\">\n  return Array.from(html.matchAll(SCRIPT_REGEX)).map(m => m[1]);\n};\n\nconst bundleSize = async (\n  buildDir: string,\n  prefix: string,\n  iframeScripts: string[],\n  indexScripts: string[]\n) => {\n  let preview = iframeScripts.find(f => f.startsWith(prefix));\n  let manager = indexScripts.find(f => f.startsWith(prefix));\n\n  // FIXME: webpack5 uses `290.d3d846e4d074e7386081.bundle.js`\n  if (prefix === 'vendors') {\n    manager =\n      manager ||\n      indexScripts.find(f => !f.startsWith('main') && !f.startsWith('runtime'));\n    preview =\n      preview ||\n      iframeScripts.find(\n        f => !f.startsWith('main') && !f.startsWith('runtime')\n      );\n  }\n\n  // FIXME: vite uses '/assets/iframe.d7d1f891.js`, no vendors or runtime\n  if (!preview && prefix === 'main') {\n    preview = iframeScripts.find(f => f.startsWith('/assets/iframe'));\n  }\n\n  if (!manager) {\n    throw new Error(`Missing manager files for '${prefix}')}`);\n  }\n\n  return {\n    manager: await du(path.join(buildDir, manager)),\n    preview: preview ? await du(path.join(buildDir, preview)) : 0,\n  };\n};\n\nconst safeDu = async (filePath: string) => {\n  try {\n    return await du(filePath);\n  } catch {\n    return 0;\n  }\n};\n\nexport const bundleSizes = async (buildDir: string) => {\n  const iframe = getScripts(\n    fs.readFileSync(path.join(buildDir, 'iframe.html')).toString()\n  );\n  const index = getScripts(\n    fs.readFileSync(path.join(buildDir, 'index.html')).toString()\n  );\n\n  const [main, runtime, vendors, docsDll, uiDll] = await Promise.all([\n    bundleSize(buildDir, 'main', iframe, index),\n    bundleSize(buildDir, 'runtime', iframe, index),\n    bundleSize(buildDir, 'vendors', iframe, index),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_docs_dll.js')),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_ui_dll.js')),\n  ]);\n\n  return {\n    manager: {\n      total: main.manager + runtime.manager + vendors.manager,\n      main: main.manager,\n      runtime: runtime.manager,\n      vendors: vendors.manager,\n      uiDll,\n    },\n    preview: {\n      total: main.preview + runtime.preview + vendors.preview,\n      main: main.preview,\n      runtime: runtime.preview,\n      vendors: vendors.preview,\n      docsDll,\n    },\n  };\n};\n\nexport const cleanup = async () => {\n  rimraf.sync(BUILD_DIR);\n};\n\nexport const buildBrowseStorybook = async (extraFlags: string[]) => {\n  console.log('measuring build-storybook');\n\n  Tick.wrap(function build(done: () => void) {\n    spawnSync('yarn', ['build-storybook', ...extraFlags], { stdio: STDIO });\n    done();\n  });\n\n  let resolve: any;\n  const promise = new Promise((res: any) => {\n    resolve = res;\n  });\n\n  const stats = resetStats();\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  const staticServer = await makeStaticServer();\n\n  let statsServer: any;\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('resolving browse');\n    resolve();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('stopping static server');\n    await staticServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  const page = await browser.newPage();\n  await page.goto(`http://127.0.0.1:${STATIC_STORYBOOK_PORT}/index.html`);\n\n  await promise;\n\n  const build = {\n    time: {\n      build: timers.build.duration(),\n    },\n    size: {},\n  };\n\n  const bundles = await bundleSizes(BUILD_DIR);\n  const browse = {\n    size: {\n      total: await du(BUILD_DIR),\n      ...bundles,\n    },\n    time: stats.time,\n  };\n\n  return { build, browse };\n};\n","import fs from 'fs';\nimport { sync as spawnSync } from 'cross-spawn';\n\nconst ADDONS_REGEX = /(addons.*\\:.*\\[)/g;\nconst STDIO = 'inherit';\n\nconst insertAddonBench = (main: string) => {\n  const lines = main.split('\\n');\n  const updated = lines.map(line =>\n    line.replace(ADDONS_REGEX, '$1 \"@storybook/addon-bench\",')\n  );\n  return updated.join('\\n');\n};\n\nexport const installAddonBench = async () => {\n  let commandArgs = ['add', '@storybook/addon-bench', '--dev'];\n  if (isUsingYarn1()) {\n    commandArgs.push('-W');\n  }\n  spawnSync('yarn', commandArgs, {\n    stdio: STDIO,\n  });\n  const mainFile = '.storybook/main.js';\n  const main = fs.readFileSync(mainFile).toString();\n  if (!main.includes('@storybook/addon-bench')) {\n    const mainWithBench = insertAddonBench(main);\n    fs.writeFileSync(mainFile, mainWithBench);\n  }\n};\n\nconst isUsingYarn1 = (): boolean => {\n  const yarnVersionCommand = spawnSync('yarn', ['--version']);\n\n  if (yarnVersionCommand.status !== 0) {\n    throw new Error(`ðŸ§¶ Yarn must be installed to run '@storybook/bench'`);\n  }\n\n  const yarnVersion = yarnVersionCommand.output\n    .toString()\n    .replace(/,/g, '')\n    .replace(/\"/g, '');\n\n  return /^1\\.+/.test(yarnVersion);\n};\n","import { spawn } from 'cross-spawn';\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport Hapi from '@hapi/hapi';\nimport puppeteer from 'puppeteer';\n\nconst MANAGER_PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for manager and (\\d*\\.?\\d*) s for preview/gm;\nconst PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for preview/gm;\nconst DEV_PORT = 9999;\n\nconst logger = console;\n\nexport const startStorybook = async (extraFlags: string[]) => {\n  console.log('measuring start-storybook');\n\n  let resolveBuild: any;\n  const buildFinished = new Promise((res: any) => {\n    resolveBuild = res;\n  });\n\n  let resolveRender: any;\n  const renderFinished = new Promise((res: any) => {\n    resolveRender = res;\n  });\n\n  const stats = resetStats();\n  const child = spawn(\n    'yarn',\n    ['start-storybook', '-p', DEV_PORT.toString(), '--ci', ...extraFlags],\n    {\n      stdio: 'pipe',\n    }\n  );\n\n  let managerWebpack = -1;\n  let previewWebpack = -1;\n  child.stdout.on('data', data => {\n    const output = data.toString();\n    //â”‚   8.42 s for manager and 8.86 s for preview       â”‚\n    let match = MANAGER_PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 1000000000 * parseFloat(match[1]);\n      previewWebpack = 1000000000 * parseFloat(match[2]);\n      resolveBuild();\n    }\n    //â”‚   8.86 s for preview       â”‚\n    match = PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 0;\n      previewWebpack = 1000000000 * parseFloat(match[1]);\n      resolveBuild();\n    }\n  });\n  child.on('exit', () => {\n    logger.log('closing start-storybook');\n    resolveRender();\n  });\n  let statsServer: Hapi.Server;\n\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('killing start-storybook');\n    child.kill();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  await buildFinished;\n\n  const page = await browser.newPage();\n  await page.goto(`http://localhost:${DEV_PORT}/index.html`);\n\n  await renderFinished;\n\n  const webpackStats = {\n    managerWebpack,\n    previewWebpack,\n  };\n\n  return {\n    time: {\n      ...webpackStats,\n      ...stats.time,\n    },\n    size: {},\n  };\n};\n","const GCP_CREDENTIALS = JSON.parse(process.env.GCP_CREDENTIALS || '{}');\nconst SB_BENCH_UPLOAD = process.env.SB_BENCH_UPLOAD === 'true';\nconst { CIRCLE_BRANCH, CIRCLE_SHA1 } = process.env;\n\nexport { SB_BENCH_UPLOAD, GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 };\n","import { BigQuery } from '@google-cloud/bigquery';\nimport { sync as spawnSync } from 'cross-spawn';\nimport { GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 } from './environment';\nimport fs from 'fs';\n\nconst _gitHelper = (args: string[]): string => {\n  const result = spawnSync('git', args, { stdio: 'pipe' });\n  if (result.error) {\n    throw result.error;\n  }\n  return result.output.join('\\n').trim();\n};\n\nconst gitBranch = () => _gitHelper(['rev-parse', '--abbrev-ref', 'HEAD']);\nconst gitCommit = () => _gitHelper(['rev-parse', 'HEAD']);\n\nexport const upload = async (\n  { install, start, build, browse }: any,\n  label: string\n) => {\n  console.log('uploading to label', label);\n\n  const row = {\n    branch: CIRCLE_BRANCH || gitBranch(),\n    commit: CIRCLE_SHA1 || gitCommit(),\n    timestamp: new Date().toISOString(),\n    label,\n    installTime: install.time.total,\n    installSize: install.size.total,\n    startManagerBuild: start.time.managerWebpack,\n    startPreviewBuild: start.time.previewWebpack,\n    startManagerRender: start.time.managerRender,\n    startPreviewRender: start.time.previewRender,\n    buildTime: build.time.build,\n    browseManagerRender: browse.time.managerRender,\n    browsePreviewRender: browse.time.previewRender,\n    browseSizeTotal: browse.size.total,\n    browseSizeManagerTotal: browse.size.manager.total,\n    browseSizeManagerVendors: browse.size.manager.vendors,\n    browseSizeManagerUiDll: browse.size.manager.uiDll,\n    browseSizePreviewTotal: browse.size.preview.total,\n    browseSizePreviewVendors: browse.size.preview.vendors,\n    browseSizePreviewDocsDll: browse.size.preview.docsDll,\n  };\n\n  const bigquery = new BigQuery({\n    projectId: GCP_CREDENTIALS.project_id,\n    credentials: GCP_CREDENTIALS,\n  });\n  const dataset = bigquery.dataset('benchmark_results');\n  const appTable = dataset.table('bench');\n\n  await appTable.insert([row]);\n};\n\nexport const main = async () => {\n  const results = JSON.parse(fs.readFileSync('./bench.json').toString());\n  try {\n    await upload(results, 'bench');\n  } catch (err) {\n    console.log(err);\n    (err.errors || []).map((sub: any) => console.log(sub));\n  }\n};\n","import mapValues from 'lodash/mapValues';\nimport prettyBytes from 'pretty-bytes';\n\nconst prettyTime = (duration: number) => (duration / 1000000000.0).toFixed(2);\n\nconst mapValuesDeep = (obj: any, formatFn: any): any =>\n  typeof obj === 'object'\n    ? mapValues(obj, val => mapValuesDeep(val, formatFn))\n    : formatFn(obj);\n\nexport const formatString = (result: Record<string, any>) => ({\n  time: mapValuesDeep(result.time, prettyTime),\n  size: mapValuesDeep(result.size, prettyBytes),\n});\n\nconst toMS = (val: number) => Math.round(val / 1000000);\nconst toKB = (val: number) => Math.round(val / 1024);\n\nexport const formatNumber = (result: Record<string, any>) =>\n  mapValues(result, val => ({\n    time: mapValuesDeep(val.time, toMS),\n    size: mapValuesDeep(val.size, toKB),\n  }));\n","import jsonexport from 'jsonexport';\nimport program from 'commander';\nimport fs from 'fs';\n\nimport { cleanup, buildBrowseStorybook } from './buildBrowseStorybook';\nimport { installStorybook } from './installStorybook';\nimport { startStorybook } from './startStorybook';\n\nimport { upload } from './upload';\nimport { formatNumber } from './helpers/format';\nimport { SB_BENCH_UPLOAD } from './environment';\n\nconst stub = (arg?: any) => ({ time: {}, size: {} });\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst save = async (results: Record<string, any>, label: string) => {\n  const csv = await jsonexport(results);\n  fs.writeFileSync(`${label}.csv`, csv);\n  fs.writeFileSync(`${label}.json`, JSON.stringify(results));\n};\n\ninterface Options {\n  installCommand: string;\n  label: string;\n  extraFlags: string[];\n  benchmarks: {\n    install: boolean;\n    start: boolean;\n    browse: boolean;\n  };\n}\n\nconst benchmark = async ({\n  installCommand,\n  label,\n  extraFlags,\n  benchmarks,\n}: Options) => {\n  await cleanup();\n\n  const install = benchmarks.install\n    ? await installStorybook(installCommand)\n    : {};\n  const start = benchmarks.start ? await startStorybook(extraFlags) : {};\n  const browse = benchmarks.browse\n    ? await buildBrowseStorybook(extraFlags)\n    : { build: {}, browse: {} };\n\n  const bench = formatNumber({ install, start, ...browse });\n  await save(bench, label);\n\n  return bench;\n};\n\nexport const main = async () => {\n  program.arguments('[installCommand]');\n  program.option(\n    '-l, --label <label>',\n    'Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true',\n    'bench'\n  );\n  program.option(\n    '-e, --extra-flags <flags>',\n    'Run storybook with extra flags (e.g. \"--no-dll\")',\n    ''\n  );\n  program.option('--no-install', 'Do not measure storybook install time');\n  program.option('--no-start', 'Do not measure storybook start time');\n  program.option('--no-browse', 'Do not measure storybook browse time');\n  program.parse(process.argv);\n  if (program.install && !program.args.length) {\n    program.help();\n  }\n\n  const { label, extraFlags, install, start, browse } = program;\n  const installCommand = program.args[0];\n  const flags = extraFlags.length > 0 ? extraFlags.split(' ') : [];\n\n  const bench = await benchmark({\n    installCommand,\n    label,\n    extraFlags: flags,\n    benchmarks: {\n      install,\n      start,\n      browse,\n    },\n  });\n  if (SB_BENCH_UPLOAD) {\n    await upload(bench, label);\n  }\n};\n","import Hapi from '@hapi/hapi';\nimport Inert from '@hapi/inert';\nimport path from 'path';\n\nexport const STATIC_STORYBOOK_PORT = 9899;\n\nexport const makeStaticServer = async () => {\n  const server = new Hapi.Server({\n    port: STATIC_STORYBOOK_PORT,\n  });\n  await server.register(Inert);\n\n  server.route({\n    method: 'GET',\n    path: '/{param*}',\n    handler: async (req, h) => {\n      const filePath = path.join(process.cwd(), 'storybook-static', req.path);\n      return h.file(filePath, { confine: false });\n    },\n  });\n\n  await server.start();\n  console.log('Static server:', server.info.uri);\n  return server;\n};\n","import { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport { Tick, timers } from 'exectimer';\nimport { installAddonBench } from './installAddonBench';\n\nconst NODE_MODULES = 'node_modules';\nconst STDIO = 'inherit';\n\nexport const installStorybook = async (installCommand: string) => {\n  console.log('measuring install');\n  if (!installCommand) {\n    console.warn('No install command provided');\n    return {\n      size: { total: 0 },\n      time: { total: 0 },\n    };\n  }\n\n  const initialSize = await du(NODE_MODULES);\n  Tick.wrap(function install(done: () => void) {\n    const [cmd, ...args] = installCommand.split(' ');\n    spawnSync(cmd, args, { stdio: STDIO });\n    done();\n  });\n  const finalSize = await du(NODE_MODULES);\n\n  // Add instrumentation addon AFTER we've measured install size\n  await installAddonBench();\n\n  return {\n    size: { total: finalSize - initialSize },\n    time: { total: timers.install.duration() },\n  };\n};\n"],"names":["Symbol","iterator","asyncIterator","EVENTS","puppeteerArgs","now","Date","getTime","resetStats","stats","result","init","time","forEach","evt","makeStatsServer","done","server","Hapi","Server","port","event","route","method","path","handler","req","h","console","log","response","code","start","SCRIPT_REGEX","logger","getScripts","html","Array","from","matchAll","map","m","bundleSize","buildDir","prefix","iframeScripts","indexScripts","preview","find","f","startsWith","manager","Error","du","join","safeDu","filePath","body","recover","e","then","ADDONS_REGEX","MANAGER_PREVIEW_REGEX","PREVIEW_REGEX","GCP_CREDENTIALS","JSON","parse","process","env","SB_BENCH_UPLOAD","CIRCLE_BRANCH","CIRCLE_SHA1","_gitHelper","args","spawnSync","stdio","error","output","trim","mapValuesDeep","obj","formatFn","mapValues","val","toMS","Math","round","toKB","program","arguments","option","argv","install","length","help","label","extraFlags","browse","installCommand","flags","split","benchmarks","rimraf","sync","cleanup","bench","size","results","jsonexport","csv","fs","writeFileSync","stringify","save","resolve","Tick","wrap","promise","Promise","res","puppeteer","launch","browser","register","Inert","cwd","file","confine","info","uri","makeStaticServer","staticServer","statsServer","stop","close","newPage","page","build","timers","duration","iframe","readFileSync","toString","index","all","main","runtime","vendors","total","uiDll","docsDll","bundleSizes","bundles","buildBrowseStorybook","resolveBuild","resolveRender","buildFinished","renderFinished","child","spawn","managerWebpack","previewWebpack","stdout","on","data","match","exec","parseFloat","kill","startStorybook","initialSize","cmd","finalSize","commandArgs","yarnVersionCommand","status","yarnVersion","replace","test","isUsingYarn1","push","includes","mainWithBench","line","insertAddonBench","installAddonBench","warn","installStorybook","benchmark","row","branch","commit","timestamp","toISOString","installTime","installSize","startManagerBuild","startPreviewBuild","startManagerRender","managerRender","startPreviewRender","previewRender","buildTime","browseManagerRender","browsePreviewRender","browseSizeTotal","browseSizeManagerTotal","browseSizeManagerVendors","browseSizeManagerUiDll","browseSizePreviewTotal","browseSizePreviewVendors","browseSizePreviewDocsDll","appTable","BigQuery","projectId","project_id","credentials","dataset","table","insert","upload"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"bench.cjs.production.min.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/helpers/timing.ts","../src/buildBrowseStorybook.ts","../src/installAddonBench.ts","../src/startStorybook.ts","../src/environment.ts","../src/upload.ts","../src/helpers/format.ts","../src/index.ts","../src/installStorybook.ts","../src/helpers/static.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import Hapi from '@hapi/hapi';\n\nexport const EVENTS = ['managerRender', 'previewRender', 'storyRender'];\nexport const STATS_PORT = 9898;\n\nexport type Stats = {\n  init: number;\n  time: Record<string, number | null>;\n};\n\nexport const puppeteerArgs = ['--no-sandbox', '--disable-setuid-sandbox'];\n\nconst now = () => new Date().getTime();\n\nexport const resetStats = (stats?: Stats) => {\n  const result = stats || ({ init: now(), time: {} } as Stats);\n  result.init = now();\n  EVENTS.forEach(evt => (result.time[evt] = null));\n  return result;\n};\n\nexport const makeStatsServer = async (stats: Stats, done: any) => {\n  const server = new Hapi.Server({ port: STATS_PORT });\n\n  const addEvent = (event: string) => {\n    server.route({\n      method: 'GET',\n      path: `/${event}`,\n      handler: async (req: any, h: any) => {\n        console.log(`HANDLER: ${event}`, stats);\n        if (!stats.time[event]) {\n          stats.time[event] = (now() - stats.init) * 1000000;\n        }\n        if (event === 'storyRender') {\n          done();\n        }\n        return h.response('ok').code(200);\n      },\n    });\n  };\n\n  EVENTS.forEach(evt => addEvent(evt));\n  await server.start();\n  return server;\n};\n","import { Tick, timers } from 'exectimer';\nimport { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport fs from 'fs';\nimport path from 'path';\nimport rimraf from 'rimraf';\nimport puppeteer from 'puppeteer';\n\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport { makeStaticServer, STATIC_STORYBOOK_PORT } from './helpers/static';\n\nconst STDIO = 'inherit';\nconst BUILD_DIR = 'storybook-static';\n\nconst SCRIPT_REGEX = /<script.*?src=\"(.[^\"]*\\.js)\">/g;\nconst logger = console;\n\nconst getScripts = (html: string) => {\n  // <script src=\"runtime~main.6a9b04192e3176eff72a.bundle.js\">\n  return Array.from(html.matchAll(SCRIPT_REGEX)).map(m => m[1]);\n};\n\nconst bundleSize = async (\n  buildDir: string,\n  prefix: string,\n  iframeScripts: string[],\n  indexScripts: string[]\n) => {\n  let preview = iframeScripts.find(f => f.startsWith(prefix));\n  let manager = indexScripts.find(f => f.startsWith(prefix));\n\n  // FIXME: webpack5 uses `290.d3d846e4d074e7386081.bundle.js`\n  if (prefix === 'vendors') {\n    manager =\n      manager ||\n      indexScripts.find(f => !f.startsWith('main') && !f.startsWith('runtime'));\n    preview =\n      preview ||\n      iframeScripts.find(\n        f => !f.startsWith('main') && !f.startsWith('runtime')\n      );\n  }\n\n  // FIXME: vite uses '/assets/iframe.d7d1f891.js`, no vendors or runtime\n  if (!preview && prefix === 'main') {\n    preview = iframeScripts.find(f => f.startsWith('/assets/iframe'));\n  }\n\n  if (!manager) {\n    throw new Error(`Missing manager files for '${prefix}')}`);\n  }\n\n  return {\n    manager: await du(path.join(buildDir, manager)),\n    preview: preview ? await du(path.join(buildDir, preview)) : 0,\n  };\n};\n\nconst safeDu = async (filePath: string) => {\n  try {\n    return await du(filePath);\n  } catch {\n    return 0;\n  }\n};\n\nexport const bundleSizes = async (buildDir: string) => {\n  const iframe = getScripts(\n    fs.readFileSync(path.join(buildDir, 'iframe.html')).toString()\n  );\n  const index = getScripts(\n    fs.readFileSync(path.join(buildDir, 'index.html')).toString()\n  );\n\n  const [main, runtime, vendors, docsDll, uiDll] = await Promise.all([\n    bundleSize(buildDir, 'main', iframe, index),\n    bundleSize(buildDir, 'runtime', iframe, index),\n    bundleSize(buildDir, 'vendors', iframe, index),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_docs_dll.js')),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_ui_dll.js')),\n  ]);\n\n  return {\n    manager: {\n      total: main.manager + runtime.manager + vendors.manager,\n      main: main.manager,\n      runtime: runtime.manager,\n      vendors: vendors.manager,\n      uiDll,\n    },\n    preview: {\n      total: main.preview + runtime.preview + vendors.preview,\n      main: main.preview,\n      runtime: runtime.preview,\n      vendors: vendors.preview,\n      docsDll,\n    },\n  };\n};\n\nexport const cleanup = async () => {\n  rimraf.sync(BUILD_DIR);\n};\n\nexport const buildBrowseStorybook = async (extraFlags: string[]) => {\n  console.log('measuring build-storybook');\n\n  Tick.wrap(function build(done: () => void) {\n    spawnSync('yarn', ['build-storybook', ...extraFlags], { stdio: STDIO });\n    done();\n  });\n\n  let resolve: any;\n  const promise = new Promise((res: any) => {\n    resolve = res;\n  });\n\n  const stats = resetStats();\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  const staticServer = await makeStaticServer();\n\n  let statsServer: any;\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('resolving browse');\n    resolve();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('stopping static server');\n    await staticServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  const page = await browser.newPage();\n  await page.goto(`http://127.0.0.1:${STATIC_STORYBOOK_PORT}/index.html`);\n\n  await promise;\n\n  const build = {\n    time: {\n      build: timers.build.duration(),\n    },\n    size: {},\n  };\n\n  const bundles = await bundleSizes(BUILD_DIR);\n  const browse = {\n    size: {\n      total: await du(BUILD_DIR),\n      ...bundles,\n    },\n    time: stats.time,\n  };\n\n  return { build, browse };\n};\n","import fs from 'fs';\nimport { sync as spawnSync } from 'cross-spawn';\n\nconst ADDONS_REGEX = /(addons.*\\:.*\\[)/g;\nconst STDIO = 'inherit';\n\nconst insertAddonBench = (main: string) => {\n  const lines = main.split('\\n');\n  const updated = lines.map(line =>\n    line.replace(ADDONS_REGEX, '$1 \"@storybook/addon-bench\",')\n  );\n  return updated.join('\\n');\n};\n\nexport const installAddonBench = async () => {\n  let commandArgs = ['add', '@storybook/addon-bench', '--dev'];\n  if (isUsingYarn1()) {\n    commandArgs.push('-W');\n  }\n  spawnSync('yarn', commandArgs, {\n    stdio: STDIO,\n  });\n  const mainFile = '.storybook/main.js';\n  const main = fs.readFileSync(mainFile).toString();\n  if (!main.includes('@storybook/addon-bench')) {\n    const mainWithBench = insertAddonBench(main);\n    fs.writeFileSync(mainFile, mainWithBench);\n  }\n};\n\nconst isUsingYarn1 = (): boolean => {\n  const yarnVersionCommand = spawnSync('yarn', ['--version']);\n\n  if (yarnVersionCommand.status !== 0) {\n    throw new Error(`ðŸ§¶ Yarn must be installed to run '@storybook/bench'`);\n  }\n\n  const yarnVersion = yarnVersionCommand.output\n    .toString()\n    .replace(/,/g, '')\n    .replace(/\"/g, '');\n\n  return /^1\\.+/.test(yarnVersion);\n};\n","import { spawn } from 'cross-spawn';\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport Hapi from '@hapi/hapi';\nimport puppeteer from 'puppeteer';\n\nconst MANAGER_PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for manager and (\\d*\\.?\\d*) s for preview/gm;\nconst PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for preview/gm;\nconst DEV_PORT = 9999;\n\nconst logger = console;\n\nexport const startStorybook = async (extraFlags: string[]) => {\n  console.log('measuring start-storybook');\n\n  let resolveBuild: any;\n  const buildFinished = new Promise((res: any) => {\n    resolveBuild = res;\n  });\n\n  let resolveRender: any;\n  const renderFinished = new Promise((res: any) => {\n    resolveRender = res;\n  });\n\n  const stats = resetStats();\n  const child = spawn(\n    'yarn',\n    ['start-storybook', '-p', DEV_PORT.toString(), '--ci', ...extraFlags],\n    {\n      stdio: 'pipe',\n    }\n  );\n\n  let managerWebpack = -1;\n  let previewWebpack = -1;\n  // Needed for webpack 4\n  // child.stderr.on('data', d => {\n  //   console.log(d.toString());\n  // });\n  child.stdout.on('data', data => {\n    const output = data.toString();\n    //â”‚   8.42 s for manager and 8.86 s for preview       â”‚\n    let match = MANAGER_PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 1000000000 * parseFloat(match[1]);\n      previewWebpack = 1000000000 * parseFloat(match[2]);\n      resolveBuild();\n    }\n    //â”‚   8.86 s for preview       â”‚\n    match = PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 0;\n      previewWebpack = 1000000000 * parseFloat(match[1]);\n      resolveBuild();\n    }\n  });\n  child.on('exit', () => {\n    logger.log('closing start-storybook');\n    resolveRender();\n  });\n  let statsServer: Hapi.Server;\n\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('killing start-storybook');\n    child.kill();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  await buildFinished;\n\n  const page = await browser.newPage();\n  await page.goto(`http://localhost:${DEV_PORT}`);\n  await renderFinished;\n\n  const webpackStats = {\n    managerWebpack,\n    previewWebpack,\n  };\n\n  return {\n    time: {\n      ...webpackStats,\n      ...stats.time,\n    },\n    size: {},\n  };\n};\n","const GCP_CREDENTIALS = JSON.parse(process.env.GCP_CREDENTIALS || '{}');\nconst SB_BENCH_UPLOAD = process.env.SB_BENCH_UPLOAD === 'true';\nconst { CIRCLE_BRANCH, CIRCLE_SHA1 } = process.env;\n\nexport { SB_BENCH_UPLOAD, GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 };\n","import { BigQuery } from '@google-cloud/bigquery';\nimport { sync as spawnSync } from 'cross-spawn';\nimport { GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 } from './environment';\nimport fs from 'fs';\n\nconst _gitHelper = (args: string[]): string => {\n  const result = spawnSync('git', args, { stdio: 'pipe' });\n  if (result.error) {\n    throw result.error;\n  }\n  return result.output.join('\\n').trim();\n};\n\nconst gitBranch = () => _gitHelper(['rev-parse', '--abbrev-ref', 'HEAD']);\nconst gitCommit = () => _gitHelper(['rev-parse', 'HEAD']);\n\nexport const upload = async (\n  { install, start, build, browse }: any,\n  label: string\n) => {\n  console.log('uploading to label', label);\n\n  const row = {\n    branch: CIRCLE_BRANCH || gitBranch(),\n    commit: CIRCLE_SHA1 || gitCommit(),\n    timestamp: new Date().toISOString(),\n    label,\n    installTime: install.time.total,\n    installSize: install.size.total,\n    startManagerBuild: start.time.managerWebpack,\n    startPreviewBuild: start.time.previewWebpack,\n    startManagerRender: start.time.managerRender,\n    startPreviewRender: start.time.previewRender,\n    buildTime: build.time.build,\n    browseManagerRender: browse.time.managerRender,\n    browsePreviewRender: browse.time.previewRender,\n    browseSizeTotal: browse.size.total,\n    browseSizeManagerTotal: browse.size.manager.total,\n    browseSizeManagerVendors: browse.size.manager.vendors,\n    browseSizeManagerUiDll: browse.size.manager.uiDll,\n    browseSizePreviewTotal: browse.size.preview.total,\n    browseSizePreviewVendors: browse.size.preview.vendors,\n    browseSizePreviewDocsDll: browse.size.preview.docsDll,\n  };\n\n  const bigquery = new BigQuery({\n    projectId: GCP_CREDENTIALS.project_id,\n    credentials: GCP_CREDENTIALS,\n  });\n  const dataset = bigquery.dataset('benchmark_results');\n  const appTable = dataset.table('bench');\n\n  await appTable.insert([row]);\n};\n\nexport const main = async () => {\n  const results = JSON.parse(fs.readFileSync('./bench.json').toString());\n  try {\n    await upload(results, 'bench');\n  } catch (err) {\n    console.log(err);\n    (err.errors || []).map((sub: any) => console.log(sub));\n  }\n};\n","import mapValues from 'lodash/mapValues';\nimport prettyBytes from 'pretty-bytes';\n\nconst prettyTime = (duration: number) => (duration / 1000000000.0).toFixed(2);\n\nconst mapValuesDeep = (obj: any, formatFn: any): any =>\n  typeof obj === 'object'\n    ? mapValues(obj, val => mapValuesDeep(val, formatFn))\n    : formatFn(obj);\n\nexport const formatString = (result: Record<string, any>) => ({\n  time: mapValuesDeep(result.time, prettyTime),\n  size: mapValuesDeep(result.size, prettyBytes),\n});\n\nconst toMS = (val: number) => Math.round(val / 1000000);\nconst toKB = (val: number) => Math.round(val / 1024);\n\nexport const formatNumber = (result: Record<string, any>) =>\n  mapValues(result, val => ({\n    time: mapValuesDeep(val.time, toMS),\n    size: mapValuesDeep(val.size, toKB),\n  }));\n","import jsonexport from 'jsonexport';\nimport program from 'commander';\nimport fs from 'fs';\n\nimport { cleanup, buildBrowseStorybook } from './buildBrowseStorybook';\nimport { installStorybook } from './installStorybook';\nimport { startStorybook } from './startStorybook';\n\nimport { upload } from './upload';\nimport { formatNumber } from './helpers/format';\nimport { SB_BENCH_UPLOAD } from './environment';\n\nconst stub = (arg?: any) => ({ time: {}, size: {} });\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst save = async (results: Record<string, any>, label: string) => {\n  const csv = await jsonexport(results);\n  fs.writeFileSync(`${label}.csv`, csv);\n  fs.writeFileSync(`${label}.json`, JSON.stringify(results));\n};\n\ninterface Options {\n  installCommand: string;\n  label: string;\n  extraFlags: string[];\n}\n\nconst benchmark = async ({ installCommand, label, extraFlags }: Options) => {\n  await cleanup();\n\n  const install = await installStorybook(installCommand);\n  const start = await startStorybook(extraFlags);\n  const { build, browse } = await buildBrowseStorybook(extraFlags);\n\n  const bench = formatNumber({ install, start, build, browse });\n  await save(bench, label);\n\n  return bench;\n};\n\nexport const main = async () => {\n  program.arguments('<installCommand>');\n  program.option(\n    '-l, --label <label>',\n    'Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true',\n    'bench'\n  );\n  program.option(\n    '-e, --extra-flags <flags>',\n    'Run storybook with extra flags (e.g. \"--no-dll\")',\n    ''\n  );\n  program.parse(process.argv);\n  if (!program.args.length) {\n    program.help();\n  }\n\n  const { label, extraFlags } = program;\n  const installCommand = program.args[0];\n  const flags = extraFlags.length > 0 ? extraFlags.split(' ') : [];\n\n  const bench = await benchmark({ installCommand, label, extraFlags: flags });\n  if (SB_BENCH_UPLOAD) {\n    await upload(bench, label);\n  }\n};\n","import { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport { Tick, timers } from 'exectimer';\nimport { installAddonBench } from './installAddonBench';\n\nconst NODE_MODULES = 'node_modules';\nconst STDIO = 'inherit';\n\nexport const installStorybook = async (installCommand: string) => {\n  console.log('measuring install');\n  if (!installCommand) {\n    console.warn('No install command provided');\n    return {\n      size: { total: 0 },\n      time: { total: 0 },\n    };\n  }\n\n  const initialSize = await du(NODE_MODULES);\n  Tick.wrap(function install(done: () => void) {\n    const [cmd, ...args] = installCommand.split(' ');\n    spawnSync(cmd, args, { stdio: STDIO });\n    done();\n  });\n  const finalSize = await du(NODE_MODULES);\n\n  // Add instrumentation addon AFTER we've measured install size\n  await installAddonBench();\n\n  return {\n    size: { total: finalSize - initialSize },\n    time: { total: timers.install.duration() },\n  };\n};\n","import Hapi from '@hapi/hapi';\nimport Inert from '@hapi/inert';\nimport path from 'path';\n\nexport const STATIC_STORYBOOK_PORT = 9899;\n\nexport const makeStaticServer = async () => {\n  const server = new Hapi.Server({\n    port: STATIC_STORYBOOK_PORT,\n  });\n  await server.register(Inert);\n\n  server.route({\n    method: 'GET',\n    path: '/{param*}',\n    handler: async (req, h) => {\n      const filePath = path.join(process.cwd(), 'storybook-static', req.path);\n      return h.file(filePath, { confine: false });\n    },\n  });\n\n  await server.start();\n  console.log('Static server:', server.info.uri);\n  return server;\n};\n"],"names":["Symbol","iterator","asyncIterator","EVENTS","puppeteerArgs","now","Date","getTime","resetStats","stats","result","init","time","forEach","evt","makeStatsServer","done","server","Hapi","Server","port","event","route","method","path","handler","req","h","console","log","response","code","start","SCRIPT_REGEX","logger","getScripts","html","Array","from","matchAll","map","m","bundleSize","buildDir","prefix","iframeScripts","indexScripts","preview","find","f","startsWith","manager","Error","du","join","safeDu","filePath","body","recover","e","then","ADDONS_REGEX","MANAGER_PREVIEW_REGEX","PREVIEW_REGEX","GCP_CREDENTIALS","JSON","parse","process","env","SB_BENCH_UPLOAD","CIRCLE_BRANCH","CIRCLE_SHA1","_gitHelper","args","spawnSync","stdio","error","output","trim","mapValuesDeep","obj","formatFn","mapValues","val","toMS","Math","round","toKB","program","arguments","option","argv","length","help","label","extraFlags","installCommand","flags","split","rimraf","sync","cleanup","initialSize","Tick","wrap","cmd","finalSize","commandArgs","yarnVersionCommand","status","yarnVersion","toString","replace","test","isUsingYarn1","push","main","fs","readFileSync","includes","mainWithBench","line","insertAddonBench","writeFileSync","installAddonBench","size","total","timers","install","duration","warn","installStorybook","resolveBuild","resolveRender","statsServer","buildFinished","Promise","res","renderFinished","child","spawn","managerWebpack","previewWebpack","stdout","on","data","match","exec","parseFloat","puppeteer","launch","browser","kill","stop","close","newPage","page","startStorybook","resolve","promise","register","Inert","cwd","file","confine","info","uri","makeStaticServer","staticServer","build","iframe","index","all","runtime","vendors","uiDll","docsDll","bundleSizes","bundles","browse","buildBrowseStorybook","bench","results","jsonexport","csv","stringify","save","benchmark","row","branch","commit","timestamp","toISOString","installTime","installSize","startManagerBuild","startPreviewBuild","startManagerRender","managerRender","startPreviewRender","previewRender","buildTime","browseManagerRender","browsePreviewRender","browseSizeTotal","browseSizeManagerTotal","browseSizeManagerVendors","browseSizeManagerUiDll","browseSizePreviewTotal","browseSizePreviewVendors","browseSizePreviewDocsDll","appTable","BigQuery","projectId","project_id","credentials","dataset","table","insert","upload"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/bench.esm.js b/dist/bench.esm.js
index 3dc21c510d75ae6f3b490d8d68040eefd2aa8311..cbe03e021b4effef41a3a079126a90443dbbbce1 100644
--- a/dist/bench.esm.js
+++ b/dist/bench.esm.js
@@ -50,8 +50,7 @@ function _catch(body, recover) {
 	return result;
 }
 
-var EVENTS = ['managerRender', 'previewRender']; // , 'storyRender'
-
+var EVENTS = ['managerRender', 'previewRender', 'storyRender'];
 var STATS_PORT = 9898;
 var puppeteerArgs = ['--no-sandbox', '--disable-setuid-sandbox'];
 
@@ -88,7 +87,7 @@ var makeStatsServer = function makeStatsServer(stats, done) {
               stats.time[event] = (now() - stats.init) * 1000000;
             }
 
-            if (event === 'previewRender') {
+            if (event === 'storyRender') {
               done();
             }
 
@@ -431,7 +430,11 @@ var startStorybook = function startStorybook(extraFlags) {
       stdio: 'pipe'
     });
     var managerWebpack = -1;
-    var previewWebpack = -1;
+    var previewWebpack = -1; // Needed for webpack 4
+    // child.stderr.on('data', d => {
+    //   console.log(d.toString());
+    // });
+
     child.stdout.on('data', function (data) {
       var output = data.toString(); //â”‚   8.42 s for manager and 8.86 s for preview       â”‚
 
@@ -482,7 +485,7 @@ var startStorybook = function startStorybook(extraFlags) {
         statsServer = _makeStatsServer;
         return Promise.resolve(buildFinished).then(function () {
           return Promise.resolve(browser.newPage()).then(function (page) {
-            return Promise.resolve(page["goto"]("http://localhost:" + DEV_PORT + "/index.html")).then(function () {
+            return Promise.resolve(page["goto"]("http://localhost:" + DEV_PORT)).then(function () {
               return Promise.resolve(renderFinished).then(function () {
                 var webpackStats = {
                   managerWebpack: managerWebpack,
@@ -608,36 +611,27 @@ var save = function save(results, label) {
 var benchmark = function benchmark(_ref) {
   var installCommand = _ref.installCommand,
       label = _ref.label,
-      extraFlags = _ref.extraFlags,
-      benchmarks = _ref.benchmarks;
+      extraFlags = _ref.extraFlags;
 
   try {
     return Promise.resolve(cleanup()).then(function () {
-      function _temp3(install) {
-        function _temp2(start) {
-          function _temp(browse) {
-            var bench = formatNumber(_extends({
+      return Promise.resolve(installStorybook(installCommand)).then(function (install) {
+        return Promise.resolve(startStorybook(extraFlags)).then(function (start) {
+          return Promise.resolve(buildBrowseStorybook(extraFlags)).then(function (_ref2) {
+            var build = _ref2.build,
+                browse = _ref2.browse;
+            var bench = formatNumber({
               install: install,
-              start: start
-            }, browse));
+              start: start,
+              build: build,
+              browse: browse
+            });
             return Promise.resolve(save(bench, label)).then(function () {
               return bench;
             });
-          }
-
-          var _benchmarks$browse = benchmarks.browse;
-          return _benchmarks$browse ? Promise.resolve(buildBrowseStorybook(extraFlags)).then(_temp) : _temp({
-            build: {},
-            browse: {}
           });
-        }
-
-        var _benchmarks$start = benchmarks.start;
-        return _benchmarks$start ? Promise.resolve(startStorybook(extraFlags)).then(_temp2) : _temp2({});
-      }
-
-      var _benchmarks$install = benchmarks.install;
-      return _benchmarks$install ? Promise.resolve(installStorybook(installCommand)).then(_temp3) : _temp3({});
+        });
+      });
     });
   } catch (e) {
     return Promise.reject(e);
@@ -646,42 +640,31 @@ var benchmark = function benchmark(_ref) {
 
 var main = function main() {
   try {
-    program.arguments('[installCommand]');
+    program.arguments('<installCommand>');
     program.option('-l, --label <label>', 'Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true', 'bench');
     program.option('-e, --extra-flags <flags>', 'Run storybook with extra flags (e.g. "--no-dll")', '');
-    program.option('--no-install', 'Do not measure storybook install time');
-    program.option('--no-start', 'Do not measure storybook start time');
-    program.option('--no-browse', 'Do not measure storybook browse time');
     program.parse(process.argv);
 
-    if (program.install && !program.args.length) {
+    if (!program.args.length) {
       program.help();
     }
 
     var label = program.label,
-        extraFlags = program.extraFlags,
-        install = program.install,
-        start = program.start,
-        browse = program.browse;
+        extraFlags = program.extraFlags;
     var installCommand = program.args[0];
     var flags = extraFlags.length > 0 ? extraFlags.split(' ') : [];
     return Promise.resolve(benchmark({
       installCommand: installCommand,
       label: label,
-      extraFlags: flags,
-      benchmarks: {
-        install: install,
-        start: start,
-        browse: browse
-      }
+      extraFlags: flags
     })).then(function (bench) {
-      var _temp4 = function () {
+      var _temp = function () {
         if (SB_BENCH_UPLOAD) {
           return Promise.resolve(upload(bench, label)).then(function () {});
         }
       }();
 
-      if (_temp4 && _temp4.then) return _temp4.then(function () {});
+      if (_temp && _temp.then) return _temp.then(function () {});
     });
   } catch (e) {
     return Promise.reject(e);
diff --git a/dist/bench.esm.js.map b/dist/bench.esm.js.map
index af87e170912ffc93e184c88a08b75199714116ae..151c32d85f65d7b472e4844be79c735b52b71003 100644
--- a/dist/bench.esm.js.map
+++ b/dist/bench.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"bench.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/helpers/timing.ts","../src/helpers/static.ts","../src/buildBrowseStorybook.ts","../src/installAddonBench.ts","../src/installStorybook.ts","../src/startStorybook.ts","../src/environment.ts","../src/upload.ts","../src/helpers/format.ts","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import Hapi from '@hapi/hapi';\n\nexport const EVENTS = ['managerRender', 'previewRender']; // , 'storyRender'\nexport const STATS_PORT = 9898;\n\nexport type Stats = {\n  init: number;\n  time: Record<string, number | null>;\n};\n\nexport const puppeteerArgs = ['--no-sandbox', '--disable-setuid-sandbox'];\n\nconst now = () => new Date().getTime();\n\nexport const resetStats = (stats?: Stats) => {\n  const result = stats || ({ init: now(), time: {} } as Stats);\n  result.init = now();\n  EVENTS.forEach(evt => (result.time[evt] = null));\n  return result;\n};\n\nexport const makeStatsServer = async (stats: Stats, done: any) => {\n  const server = new Hapi.Server({ port: STATS_PORT });\n\n  const addEvent = (event: string) => {\n    server.route({\n      method: 'GET',\n      path: `/${event}`,\n      handler: async (req: any, h: any) => {\n        console.log(`HANDLER: ${event}`, stats);\n        if (!stats.time[event]) {\n          stats.time[event] = (now() - stats.init) * 1000000;\n        }\n        if (event === 'previewRender') {\n          done();\n        }\n        return h.response('ok').code(200);\n      },\n    });\n  };\n\n  EVENTS.forEach(evt => addEvent(evt));\n  await server.start();\n  return server;\n};\n","import Hapi from '@hapi/hapi';\nimport Inert from '@hapi/inert';\nimport path from 'path';\n\nexport const STATIC_STORYBOOK_PORT = 9899;\n\nexport const makeStaticServer = async () => {\n  const server = new Hapi.Server({\n    port: STATIC_STORYBOOK_PORT,\n  });\n  await server.register(Inert);\n\n  server.route({\n    method: 'GET',\n    path: '/{param*}',\n    handler: async (req, h) => {\n      const filePath = path.join(process.cwd(), 'storybook-static', req.path);\n      return h.file(filePath, { confine: false });\n    },\n  });\n\n  await server.start();\n  console.log('Static server:', server.info.uri);\n  return server;\n};\n","import { Tick, timers } from 'exectimer';\nimport { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport fs from 'fs';\nimport path from 'path';\nimport rimraf from 'rimraf';\nimport puppeteer from 'puppeteer';\n\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport { makeStaticServer, STATIC_STORYBOOK_PORT } from './helpers/static';\n\nconst STDIO = 'inherit';\nconst BUILD_DIR = 'storybook-static';\n\nconst SCRIPT_REGEX = /<script.*?src=\"(.[^\"]*\\.js)\">/g;\nconst logger = console;\n\nconst getScripts = (html: string) => {\n  // <script src=\"runtime~main.6a9b04192e3176eff72a.bundle.js\">\n  return Array.from(html.matchAll(SCRIPT_REGEX)).map(m => m[1]);\n};\n\nconst bundleSize = async (\n  buildDir: string,\n  prefix: string,\n  iframeScripts: string[],\n  indexScripts: string[]\n) => {\n  let preview = iframeScripts.find(f => f.startsWith(prefix));\n  let manager = indexScripts.find(f => f.startsWith(prefix));\n\n  // FIXME: webpack5 uses `290.d3d846e4d074e7386081.bundle.js`\n  if (prefix === 'vendors') {\n    manager =\n      manager ||\n      indexScripts.find(f => !f.startsWith('main') && !f.startsWith('runtime'));\n    preview =\n      preview ||\n      iframeScripts.find(\n        f => !f.startsWith('main') && !f.startsWith('runtime')\n      );\n  }\n\n  // FIXME: vite uses '/assets/iframe.d7d1f891.js`, no vendors or runtime\n  if (!preview && prefix === 'main') {\n    preview = iframeScripts.find(f => f.startsWith('/assets/iframe'));\n  }\n\n  if (!manager) {\n    throw new Error(`Missing manager files for '${prefix}')}`);\n  }\n\n  return {\n    manager: await du(path.join(buildDir, manager)),\n    preview: preview ? await du(path.join(buildDir, preview)) : 0,\n  };\n};\n\nconst safeDu = async (filePath: string) => {\n  try {\n    return await du(filePath);\n  } catch {\n    return 0;\n  }\n};\n\nexport const bundleSizes = async (buildDir: string) => {\n  const iframe = getScripts(\n    fs.readFileSync(path.join(buildDir, 'iframe.html')).toString()\n  );\n  const index = getScripts(\n    fs.readFileSync(path.join(buildDir, 'index.html')).toString()\n  );\n\n  const [main, runtime, vendors, docsDll, uiDll] = await Promise.all([\n    bundleSize(buildDir, 'main', iframe, index),\n    bundleSize(buildDir, 'runtime', iframe, index),\n    bundleSize(buildDir, 'vendors', iframe, index),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_docs_dll.js')),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_ui_dll.js')),\n  ]);\n\n  return {\n    manager: {\n      total: main.manager + runtime.manager + vendors.manager,\n      main: main.manager,\n      runtime: runtime.manager,\n      vendors: vendors.manager,\n      uiDll,\n    },\n    preview: {\n      total: main.preview + runtime.preview + vendors.preview,\n      main: main.preview,\n      runtime: runtime.preview,\n      vendors: vendors.preview,\n      docsDll,\n    },\n  };\n};\n\nexport const cleanup = async () => {\n  rimraf.sync(BUILD_DIR);\n};\n\nexport const buildBrowseStorybook = async (extraFlags: string[]) => {\n  console.log('measuring build-storybook');\n\n  Tick.wrap(function build(done: () => void) {\n    spawnSync('yarn', ['build-storybook', ...extraFlags], { stdio: STDIO });\n    done();\n  });\n\n  let resolve: any;\n  const promise = new Promise((res: any) => {\n    resolve = res;\n  });\n\n  const stats = resetStats();\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  const staticServer = await makeStaticServer();\n\n  let statsServer: any;\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('resolving browse');\n    resolve();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('stopping static server');\n    await staticServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  const page = await browser.newPage();\n  await page.goto(`http://127.0.0.1:${STATIC_STORYBOOK_PORT}/index.html`);\n\n  await promise;\n\n  const build = {\n    time: {\n      build: timers.build.duration(),\n    },\n    size: {},\n  };\n\n  const bundles = await bundleSizes(BUILD_DIR);\n  const browse = {\n    size: {\n      total: await du(BUILD_DIR),\n      ...bundles,\n    },\n    time: stats.time,\n  };\n\n  return { build, browse };\n};\n","import fs from 'fs';\nimport { sync as spawnSync } from 'cross-spawn';\n\nconst ADDONS_REGEX = /(addons.*\\:.*\\[)/g;\nconst STDIO = 'inherit';\n\nconst insertAddonBench = (main: string) => {\n  const lines = main.split('\\n');\n  const updated = lines.map(line =>\n    line.replace(ADDONS_REGEX, '$1 \"@storybook/addon-bench\",')\n  );\n  return updated.join('\\n');\n};\n\nexport const installAddonBench = async () => {\n  let commandArgs = ['add', '@storybook/addon-bench', '--dev'];\n  if (isUsingYarn1()) {\n    commandArgs.push('-W');\n  }\n  spawnSync('yarn', commandArgs, {\n    stdio: STDIO,\n  });\n  const mainFile = '.storybook/main.js';\n  const main = fs.readFileSync(mainFile).toString();\n  if (!main.includes('@storybook/addon-bench')) {\n    const mainWithBench = insertAddonBench(main);\n    fs.writeFileSync(mainFile, mainWithBench);\n  }\n};\n\nconst isUsingYarn1 = (): boolean => {\n  const yarnVersionCommand = spawnSync('yarn', ['--version']);\n\n  if (yarnVersionCommand.status !== 0) {\n    throw new Error(`ðŸ§¶ Yarn must be installed to run '@storybook/bench'`);\n  }\n\n  const yarnVersion = yarnVersionCommand.output\n    .toString()\n    .replace(/,/g, '')\n    .replace(/\"/g, '');\n\n  return /^1\\.+/.test(yarnVersion);\n};\n","import { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport { Tick, timers } from 'exectimer';\nimport { installAddonBench } from './installAddonBench';\n\nconst NODE_MODULES = 'node_modules';\nconst STDIO = 'inherit';\n\nexport const installStorybook = async (installCommand: string) => {\n  console.log('measuring install');\n  if (!installCommand) {\n    console.warn('No install command provided');\n    return {\n      size: { total: 0 },\n      time: { total: 0 },\n    };\n  }\n\n  const initialSize = await du(NODE_MODULES);\n  Tick.wrap(function install(done: () => void) {\n    const [cmd, ...args] = installCommand.split(' ');\n    spawnSync(cmd, args, { stdio: STDIO });\n    done();\n  });\n  const finalSize = await du(NODE_MODULES);\n\n  // Add instrumentation addon AFTER we've measured install size\n  await installAddonBench();\n\n  return {\n    size: { total: finalSize - initialSize },\n    time: { total: timers.install.duration() },\n  };\n};\n","import { spawn } from 'cross-spawn';\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport Hapi from '@hapi/hapi';\nimport puppeteer from 'puppeteer';\n\nconst MANAGER_PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for manager and (\\d*\\.?\\d*) s for preview/gm;\nconst PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for preview/gm;\nconst DEV_PORT = 9999;\n\nconst logger = console;\n\nexport const startStorybook = async (extraFlags: string[]) => {\n  console.log('measuring start-storybook');\n\n  let resolveBuild: any;\n  const buildFinished = new Promise((res: any) => {\n    resolveBuild = res;\n  });\n\n  let resolveRender: any;\n  const renderFinished = new Promise((res: any) => {\n    resolveRender = res;\n  });\n\n  const stats = resetStats();\n  const child = spawn(\n    'yarn',\n    ['start-storybook', '-p', DEV_PORT.toString(), '--ci', ...extraFlags],\n    {\n      stdio: 'pipe',\n    }\n  );\n\n  let managerWebpack = -1;\n  let previewWebpack = -1;\n  child.stdout.on('data', data => {\n    const output = data.toString();\n    //â”‚   8.42 s for manager and 8.86 s for preview       â”‚\n    let match = MANAGER_PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 1000000000 * parseFloat(match[1]);\n      previewWebpack = 1000000000 * parseFloat(match[2]);\n      resolveBuild();\n    }\n    //â”‚   8.86 s for preview       â”‚\n    match = PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 0;\n      previewWebpack = 1000000000 * parseFloat(match[1]);\n      resolveBuild();\n    }\n  });\n  child.on('exit', () => {\n    logger.log('closing start-storybook');\n    resolveRender();\n  });\n  let statsServer: Hapi.Server;\n\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('killing start-storybook');\n    child.kill();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  await buildFinished;\n\n  const page = await browser.newPage();\n  await page.goto(`http://localhost:${DEV_PORT}/index.html`);\n\n  await renderFinished;\n\n  const webpackStats = {\n    managerWebpack,\n    previewWebpack,\n  };\n\n  return {\n    time: {\n      ...webpackStats,\n      ...stats.time,\n    },\n    size: {},\n  };\n};\n","const GCP_CREDENTIALS = JSON.parse(process.env.GCP_CREDENTIALS || '{}');\nconst SB_BENCH_UPLOAD = process.env.SB_BENCH_UPLOAD === 'true';\nconst { CIRCLE_BRANCH, CIRCLE_SHA1 } = process.env;\n\nexport { SB_BENCH_UPLOAD, GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 };\n","import { BigQuery } from '@google-cloud/bigquery';\nimport { sync as spawnSync } from 'cross-spawn';\nimport { GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 } from './environment';\nimport fs from 'fs';\n\nconst _gitHelper = (args: string[]): string => {\n  const result = spawnSync('git', args, { stdio: 'pipe' });\n  if (result.error) {\n    throw result.error;\n  }\n  return result.output.join('\\n').trim();\n};\n\nconst gitBranch = () => _gitHelper(['rev-parse', '--abbrev-ref', 'HEAD']);\nconst gitCommit = () => _gitHelper(['rev-parse', 'HEAD']);\n\nexport const upload = async (\n  { install, start, build, browse }: any,\n  label: string\n) => {\n  console.log('uploading to label', label);\n\n  const row = {\n    branch: CIRCLE_BRANCH || gitBranch(),\n    commit: CIRCLE_SHA1 || gitCommit(),\n    timestamp: new Date().toISOString(),\n    label,\n    installTime: install.time.total,\n    installSize: install.size.total,\n    startManagerBuild: start.time.managerWebpack,\n    startPreviewBuild: start.time.previewWebpack,\n    startManagerRender: start.time.managerRender,\n    startPreviewRender: start.time.previewRender,\n    buildTime: build.time.build,\n    browseManagerRender: browse.time.managerRender,\n    browsePreviewRender: browse.time.previewRender,\n    browseSizeTotal: browse.size.total,\n    browseSizeManagerTotal: browse.size.manager.total,\n    browseSizeManagerVendors: browse.size.manager.vendors,\n    browseSizeManagerUiDll: browse.size.manager.uiDll,\n    browseSizePreviewTotal: browse.size.preview.total,\n    browseSizePreviewVendors: browse.size.preview.vendors,\n    browseSizePreviewDocsDll: browse.size.preview.docsDll,\n  };\n\n  const bigquery = new BigQuery({\n    projectId: GCP_CREDENTIALS.project_id,\n    credentials: GCP_CREDENTIALS,\n  });\n  const dataset = bigquery.dataset('benchmark_results');\n  const appTable = dataset.table('bench');\n\n  await appTable.insert([row]);\n};\n\nexport const main = async () => {\n  const results = JSON.parse(fs.readFileSync('./bench.json').toString());\n  try {\n    await upload(results, 'bench');\n  } catch (err) {\n    console.log(err);\n    (err.errors || []).map((sub: any) => console.log(sub));\n  }\n};\n","import mapValues from 'lodash/mapValues';\nimport prettyBytes from 'pretty-bytes';\n\nconst prettyTime = (duration: number) => (duration / 1000000000.0).toFixed(2);\n\nconst mapValuesDeep = (obj: any, formatFn: any): any =>\n  typeof obj === 'object'\n    ? mapValues(obj, val => mapValuesDeep(val, formatFn))\n    : formatFn(obj);\n\nexport const formatString = (result: Record<string, any>) => ({\n  time: mapValuesDeep(result.time, prettyTime),\n  size: mapValuesDeep(result.size, prettyBytes),\n});\n\nconst toMS = (val: number) => Math.round(val / 1000000);\nconst toKB = (val: number) => Math.round(val / 1024);\n\nexport const formatNumber = (result: Record<string, any>) =>\n  mapValues(result, val => ({\n    time: mapValuesDeep(val.time, toMS),\n    size: mapValuesDeep(val.size, toKB),\n  }));\n","import jsonexport from 'jsonexport';\nimport program from 'commander';\nimport fs from 'fs';\n\nimport { cleanup, buildBrowseStorybook } from './buildBrowseStorybook';\nimport { installStorybook } from './installStorybook';\nimport { startStorybook } from './startStorybook';\n\nimport { upload } from './upload';\nimport { formatNumber } from './helpers/format';\nimport { SB_BENCH_UPLOAD } from './environment';\n\nconst stub = (arg?: any) => ({ time: {}, size: {} });\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst save = async (results: Record<string, any>, label: string) => {\n  const csv = await jsonexport(results);\n  fs.writeFileSync(`${label}.csv`, csv);\n  fs.writeFileSync(`${label}.json`, JSON.stringify(results));\n};\n\ninterface Options {\n  installCommand: string;\n  label: string;\n  extraFlags: string[];\n  benchmarks: {\n    install: boolean;\n    start: boolean;\n    browse: boolean;\n  };\n}\n\nconst benchmark = async ({\n  installCommand,\n  label,\n  extraFlags,\n  benchmarks,\n}: Options) => {\n  await cleanup();\n\n  const install = benchmarks.install\n    ? await installStorybook(installCommand)\n    : {};\n  const start = benchmarks.start ? await startStorybook(extraFlags) : {};\n  const browse = benchmarks.browse\n    ? await buildBrowseStorybook(extraFlags)\n    : { build: {}, browse: {} };\n\n  const bench = formatNumber({ install, start, ...browse });\n  await save(bench, label);\n\n  return bench;\n};\n\nexport const main = async () => {\n  program.arguments('[installCommand]');\n  program.option(\n    '-l, --label <label>',\n    'Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true',\n    'bench'\n  );\n  program.option(\n    '-e, --extra-flags <flags>',\n    'Run storybook with extra flags (e.g. \"--no-dll\")',\n    ''\n  );\n  program.option('--no-install', 'Do not measure storybook install time');\n  program.option('--no-start', 'Do not measure storybook start time');\n  program.option('--no-browse', 'Do not measure storybook browse time');\n  program.parse(process.argv);\n  if (program.install && !program.args.length) {\n    program.help();\n  }\n\n  const { label, extraFlags, install, start, browse } = program;\n  const installCommand = program.args[0];\n  const flags = extraFlags.length > 0 ? extraFlags.split(' ') : [];\n\n  const bench = await benchmark({\n    installCommand,\n    label,\n    extraFlags: flags,\n    benchmarks: {\n      install,\n      start,\n      browse,\n    },\n  });\n  if (SB_BENCH_UPLOAD) {\n    await upload(bench, label);\n  }\n};\n"],"names":["EVENTS","STATS_PORT","puppeteerArgs","now","Date","getTime","resetStats","stats","result","init","time","forEach","evt","makeStatsServer","done","server","Hapi","Server","port","addEvent","event","route","method","path","handler","req","h","console","log","response","code","start","STATIC_STORYBOOK_PORT","makeStaticServer","register","Inert","filePath","join","process","cwd","file","confine","info","uri","STDIO","BUILD_DIR","SCRIPT_REGEX","logger","getScripts","html","Array","from","matchAll","map","m","bundleSize","buildDir","prefix","iframeScripts","indexScripts","preview","find","f","startsWith","manager","Error","du","safeDu","bundleSizes","iframe","fs","readFileSync","toString","index","Promise","all","main","runtime","vendors","docsDll","uiDll","total","cleanup","rimraf","sync","buildBrowseStorybook","extraFlags","Tick","wrap","build","spawnSync","stdio","resolve","promise","res","puppeteer","launch","args","browser","staticServer","statsServer","stop","close","newPage","page","timers","duration","size","bundles","browse","ADDONS_REGEX","insertAddonBench","lines","split","updated","line","replace","installAddonBench","commandArgs","isUsingYarn1","push","mainFile","includes","mainWithBench","writeFileSync","yarnVersionCommand","status","yarnVersion","output","test","NODE_MODULES","installStorybook","installCommand","warn","initialSize","install","cmd","finalSize","MANAGER_PREVIEW_REGEX","PREVIEW_REGEX","DEV_PORT","startStorybook","resolveBuild","buildFinished","resolveRender","renderFinished","child","spawn","managerWebpack","previewWebpack","stdout","on","data","match","exec","parseFloat","kill","webpackStats","GCP_CREDENTIALS","JSON","parse","env","SB_BENCH_UPLOAD","CIRCLE_BRANCH","CIRCLE_SHA1","_gitHelper","error","trim","gitBranch","gitCommit","upload","label","row","branch","commit","timestamp","toISOString","installTime","installSize","startManagerBuild","startPreviewBuild","startManagerRender","managerRender","startPreviewRender","previewRender","buildTime","browseManagerRender","browsePreviewRender","browseSizeTotal","browseSizeManagerTotal","browseSizeManagerVendors","browseSizeManagerUiDll","browseSizePreviewTotal","browseSizePreviewVendors","browseSizePreviewDocsDll","bigquery","BigQuery","projectId","project_id","credentials","dataset","appTable","table","insert","mapValuesDeep","obj","formatFn","mapValues","val","toMS","Math","round","toKB","formatNumber","save","results","jsonexport","csv","stringify","benchmark","benchmarks","bench","program","arguments","option","argv","length","help","flags"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"bench.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/helpers/timing.ts","../src/helpers/static.ts","../src/buildBrowseStorybook.ts","../src/installAddonBench.ts","../src/installStorybook.ts","../src/startStorybook.ts","../src/environment.ts","../src/upload.ts","../src/helpers/format.ts","../src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import Hapi from '@hapi/hapi';\n\nexport const EVENTS = ['managerRender', 'previewRender', 'storyRender'];\nexport const STATS_PORT = 9898;\n\nexport type Stats = {\n  init: number;\n  time: Record<string, number | null>;\n};\n\nexport const puppeteerArgs = ['--no-sandbox', '--disable-setuid-sandbox'];\n\nconst now = () => new Date().getTime();\n\nexport const resetStats = (stats?: Stats) => {\n  const result = stats || ({ init: now(), time: {} } as Stats);\n  result.init = now();\n  EVENTS.forEach(evt => (result.time[evt] = null));\n  return result;\n};\n\nexport const makeStatsServer = async (stats: Stats, done: any) => {\n  const server = new Hapi.Server({ port: STATS_PORT });\n\n  const addEvent = (event: string) => {\n    server.route({\n      method: 'GET',\n      path: `/${event}`,\n      handler: async (req: any, h: any) => {\n        console.log(`HANDLER: ${event}`, stats);\n        if (!stats.time[event]) {\n          stats.time[event] = (now() - stats.init) * 1000000;\n        }\n        if (event === 'storyRender') {\n          done();\n        }\n        return h.response('ok').code(200);\n      },\n    });\n  };\n\n  EVENTS.forEach(evt => addEvent(evt));\n  await server.start();\n  return server;\n};\n","import Hapi from '@hapi/hapi';\nimport Inert from '@hapi/inert';\nimport path from 'path';\n\nexport const STATIC_STORYBOOK_PORT = 9899;\n\nexport const makeStaticServer = async () => {\n  const server = new Hapi.Server({\n    port: STATIC_STORYBOOK_PORT,\n  });\n  await server.register(Inert);\n\n  server.route({\n    method: 'GET',\n    path: '/{param*}',\n    handler: async (req, h) => {\n      const filePath = path.join(process.cwd(), 'storybook-static', req.path);\n      return h.file(filePath, { confine: false });\n    },\n  });\n\n  await server.start();\n  console.log('Static server:', server.info.uri);\n  return server;\n};\n","import { Tick, timers } from 'exectimer';\nimport { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport fs from 'fs';\nimport path from 'path';\nimport rimraf from 'rimraf';\nimport puppeteer from 'puppeteer';\n\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport { makeStaticServer, STATIC_STORYBOOK_PORT } from './helpers/static';\n\nconst STDIO = 'inherit';\nconst BUILD_DIR = 'storybook-static';\n\nconst SCRIPT_REGEX = /<script.*?src=\"(.[^\"]*\\.js)\">/g;\nconst logger = console;\n\nconst getScripts = (html: string) => {\n  // <script src=\"runtime~main.6a9b04192e3176eff72a.bundle.js\">\n  return Array.from(html.matchAll(SCRIPT_REGEX)).map(m => m[1]);\n};\n\nconst bundleSize = async (\n  buildDir: string,\n  prefix: string,\n  iframeScripts: string[],\n  indexScripts: string[]\n) => {\n  let preview = iframeScripts.find(f => f.startsWith(prefix));\n  let manager = indexScripts.find(f => f.startsWith(prefix));\n\n  // FIXME: webpack5 uses `290.d3d846e4d074e7386081.bundle.js`\n  if (prefix === 'vendors') {\n    manager =\n      manager ||\n      indexScripts.find(f => !f.startsWith('main') && !f.startsWith('runtime'));\n    preview =\n      preview ||\n      iframeScripts.find(\n        f => !f.startsWith('main') && !f.startsWith('runtime')\n      );\n  }\n\n  // FIXME: vite uses '/assets/iframe.d7d1f891.js`, no vendors or runtime\n  if (!preview && prefix === 'main') {\n    preview = iframeScripts.find(f => f.startsWith('/assets/iframe'));\n  }\n\n  if (!manager) {\n    throw new Error(`Missing manager files for '${prefix}')}`);\n  }\n\n  return {\n    manager: await du(path.join(buildDir, manager)),\n    preview: preview ? await du(path.join(buildDir, preview)) : 0,\n  };\n};\n\nconst safeDu = async (filePath: string) => {\n  try {\n    return await du(filePath);\n  } catch {\n    return 0;\n  }\n};\n\nexport const bundleSizes = async (buildDir: string) => {\n  const iframe = getScripts(\n    fs.readFileSync(path.join(buildDir, 'iframe.html')).toString()\n  );\n  const index = getScripts(\n    fs.readFileSync(path.join(buildDir, 'index.html')).toString()\n  );\n\n  const [main, runtime, vendors, docsDll, uiDll] = await Promise.all([\n    bundleSize(buildDir, 'main', iframe, index),\n    bundleSize(buildDir, 'runtime', iframe, index),\n    bundleSize(buildDir, 'vendors', iframe, index),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_docs_dll.js')),\n    safeDu(path.join(buildDir, 'sb_dll', 'storybook_ui_dll.js')),\n  ]);\n\n  return {\n    manager: {\n      total: main.manager + runtime.manager + vendors.manager,\n      main: main.manager,\n      runtime: runtime.manager,\n      vendors: vendors.manager,\n      uiDll,\n    },\n    preview: {\n      total: main.preview + runtime.preview + vendors.preview,\n      main: main.preview,\n      runtime: runtime.preview,\n      vendors: vendors.preview,\n      docsDll,\n    },\n  };\n};\n\nexport const cleanup = async () => {\n  rimraf.sync(BUILD_DIR);\n};\n\nexport const buildBrowseStorybook = async (extraFlags: string[]) => {\n  console.log('measuring build-storybook');\n\n  Tick.wrap(function build(done: () => void) {\n    spawnSync('yarn', ['build-storybook', ...extraFlags], { stdio: STDIO });\n    done();\n  });\n\n  let resolve: any;\n  const promise = new Promise((res: any) => {\n    resolve = res;\n  });\n\n  const stats = resetStats();\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  const staticServer = await makeStaticServer();\n\n  let statsServer: any;\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('resolving browse');\n    resolve();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('stopping static server');\n    await staticServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  const page = await browser.newPage();\n  await page.goto(`http://127.0.0.1:${STATIC_STORYBOOK_PORT}/index.html`);\n\n  await promise;\n\n  const build = {\n    time: {\n      build: timers.build.duration(),\n    },\n    size: {},\n  };\n\n  const bundles = await bundleSizes(BUILD_DIR);\n  const browse = {\n    size: {\n      total: await du(BUILD_DIR),\n      ...bundles,\n    },\n    time: stats.time,\n  };\n\n  return { build, browse };\n};\n","import fs from 'fs';\nimport { sync as spawnSync } from 'cross-spawn';\n\nconst ADDONS_REGEX = /(addons.*\\:.*\\[)/g;\nconst STDIO = 'inherit';\n\nconst insertAddonBench = (main: string) => {\n  const lines = main.split('\\n');\n  const updated = lines.map(line =>\n    line.replace(ADDONS_REGEX, '$1 \"@storybook/addon-bench\",')\n  );\n  return updated.join('\\n');\n};\n\nexport const installAddonBench = async () => {\n  let commandArgs = ['add', '@storybook/addon-bench', '--dev'];\n  if (isUsingYarn1()) {\n    commandArgs.push('-W');\n  }\n  spawnSync('yarn', commandArgs, {\n    stdio: STDIO,\n  });\n  const mainFile = '.storybook/main.js';\n  const main = fs.readFileSync(mainFile).toString();\n  if (!main.includes('@storybook/addon-bench')) {\n    const mainWithBench = insertAddonBench(main);\n    fs.writeFileSync(mainFile, mainWithBench);\n  }\n};\n\nconst isUsingYarn1 = (): boolean => {\n  const yarnVersionCommand = spawnSync('yarn', ['--version']);\n\n  if (yarnVersionCommand.status !== 0) {\n    throw new Error(`ðŸ§¶ Yarn must be installed to run '@storybook/bench'`);\n  }\n\n  const yarnVersion = yarnVersionCommand.output\n    .toString()\n    .replace(/,/g, '')\n    .replace(/\"/g, '');\n\n  return /^1\\.+/.test(yarnVersion);\n};\n","import { sync as spawnSync } from 'cross-spawn';\nimport du from 'du';\nimport { Tick, timers } from 'exectimer';\nimport { installAddonBench } from './installAddonBench';\n\nconst NODE_MODULES = 'node_modules';\nconst STDIO = 'inherit';\n\nexport const installStorybook = async (installCommand: string) => {\n  console.log('measuring install');\n  if (!installCommand) {\n    console.warn('No install command provided');\n    return {\n      size: { total: 0 },\n      time: { total: 0 },\n    };\n  }\n\n  const initialSize = await du(NODE_MODULES);\n  Tick.wrap(function install(done: () => void) {\n    const [cmd, ...args] = installCommand.split(' ');\n    spawnSync(cmd, args, { stdio: STDIO });\n    done();\n  });\n  const finalSize = await du(NODE_MODULES);\n\n  // Add instrumentation addon AFTER we've measured install size\n  await installAddonBench();\n\n  return {\n    size: { total: finalSize - initialSize },\n    time: { total: timers.install.duration() },\n  };\n};\n","import { spawn } from 'cross-spawn';\nimport { resetStats, makeStatsServer, puppeteerArgs } from './helpers/timing';\nimport Hapi from '@hapi/hapi';\nimport puppeteer from 'puppeteer';\n\nconst MANAGER_PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for manager and (\\d*\\.?\\d*) s for preview/gm;\nconst PREVIEW_REGEX = /^.\\s+(\\d*\\.?\\d*) s for preview/gm;\nconst DEV_PORT = 9999;\n\nconst logger = console;\n\nexport const startStorybook = async (extraFlags: string[]) => {\n  console.log('measuring start-storybook');\n\n  let resolveBuild: any;\n  const buildFinished = new Promise((res: any) => {\n    resolveBuild = res;\n  });\n\n  let resolveRender: any;\n  const renderFinished = new Promise((res: any) => {\n    resolveRender = res;\n  });\n\n  const stats = resetStats();\n  const child = spawn(\n    'yarn',\n    ['start-storybook', '-p', DEV_PORT.toString(), '--ci', ...extraFlags],\n    {\n      stdio: 'pipe',\n    }\n  );\n\n  let managerWebpack = -1;\n  let previewWebpack = -1;\n  // Needed for webpack 4\n  // child.stderr.on('data', d => {\n  //   console.log(d.toString());\n  // });\n  child.stdout.on('data', data => {\n    const output = data.toString();\n    //â”‚   8.42 s for manager and 8.86 s for preview       â”‚\n    let match = MANAGER_PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 1000000000 * parseFloat(match[1]);\n      previewWebpack = 1000000000 * parseFloat(match[2]);\n      resolveBuild();\n    }\n    //â”‚   8.86 s for preview       â”‚\n    match = PREVIEW_REGEX.exec(output);\n    if (match) {\n      console.log({ match });\n      managerWebpack = 0;\n      previewWebpack = 1000000000 * parseFloat(match[1]);\n      resolveBuild();\n    }\n  });\n  child.on('exit', () => {\n    logger.log('closing start-storybook');\n    resolveRender();\n  });\n  let statsServer: Hapi.Server;\n\n  const browser = await puppeteer.launch({ args: puppeteerArgs });\n\n  statsServer = await makeStatsServer(stats, async () => {\n    logger.log('killing start-storybook');\n    child.kill();\n    logger.log('stopping stats server');\n    await statsServer.stop();\n    logger.log('closing puppeteer');\n    await browser.close();\n  });\n\n  await buildFinished;\n\n  const page = await browser.newPage();\n  await page.goto(`http://localhost:${DEV_PORT}`);\n  await renderFinished;\n\n  const webpackStats = {\n    managerWebpack,\n    previewWebpack,\n  };\n\n  return {\n    time: {\n      ...webpackStats,\n      ...stats.time,\n    },\n    size: {},\n  };\n};\n","const GCP_CREDENTIALS = JSON.parse(process.env.GCP_CREDENTIALS || '{}');\nconst SB_BENCH_UPLOAD = process.env.SB_BENCH_UPLOAD === 'true';\nconst { CIRCLE_BRANCH, CIRCLE_SHA1 } = process.env;\n\nexport { SB_BENCH_UPLOAD, GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 };\n","import { BigQuery } from '@google-cloud/bigquery';\nimport { sync as spawnSync } from 'cross-spawn';\nimport { GCP_CREDENTIALS, CIRCLE_BRANCH, CIRCLE_SHA1 } from './environment';\nimport fs from 'fs';\n\nconst _gitHelper = (args: string[]): string => {\n  const result = spawnSync('git', args, { stdio: 'pipe' });\n  if (result.error) {\n    throw result.error;\n  }\n  return result.output.join('\\n').trim();\n};\n\nconst gitBranch = () => _gitHelper(['rev-parse', '--abbrev-ref', 'HEAD']);\nconst gitCommit = () => _gitHelper(['rev-parse', 'HEAD']);\n\nexport const upload = async (\n  { install, start, build, browse }: any,\n  label: string\n) => {\n  console.log('uploading to label', label);\n\n  const row = {\n    branch: CIRCLE_BRANCH || gitBranch(),\n    commit: CIRCLE_SHA1 || gitCommit(),\n    timestamp: new Date().toISOString(),\n    label,\n    installTime: install.time.total,\n    installSize: install.size.total,\n    startManagerBuild: start.time.managerWebpack,\n    startPreviewBuild: start.time.previewWebpack,\n    startManagerRender: start.time.managerRender,\n    startPreviewRender: start.time.previewRender,\n    buildTime: build.time.build,\n    browseManagerRender: browse.time.managerRender,\n    browsePreviewRender: browse.time.previewRender,\n    browseSizeTotal: browse.size.total,\n    browseSizeManagerTotal: browse.size.manager.total,\n    browseSizeManagerVendors: browse.size.manager.vendors,\n    browseSizeManagerUiDll: browse.size.manager.uiDll,\n    browseSizePreviewTotal: browse.size.preview.total,\n    browseSizePreviewVendors: browse.size.preview.vendors,\n    browseSizePreviewDocsDll: browse.size.preview.docsDll,\n  };\n\n  const bigquery = new BigQuery({\n    projectId: GCP_CREDENTIALS.project_id,\n    credentials: GCP_CREDENTIALS,\n  });\n  const dataset = bigquery.dataset('benchmark_results');\n  const appTable = dataset.table('bench');\n\n  await appTable.insert([row]);\n};\n\nexport const main = async () => {\n  const results = JSON.parse(fs.readFileSync('./bench.json').toString());\n  try {\n    await upload(results, 'bench');\n  } catch (err) {\n    console.log(err);\n    (err.errors || []).map((sub: any) => console.log(sub));\n  }\n};\n","import mapValues from 'lodash/mapValues';\nimport prettyBytes from 'pretty-bytes';\n\nconst prettyTime = (duration: number) => (duration / 1000000000.0).toFixed(2);\n\nconst mapValuesDeep = (obj: any, formatFn: any): any =>\n  typeof obj === 'object'\n    ? mapValues(obj, val => mapValuesDeep(val, formatFn))\n    : formatFn(obj);\n\nexport const formatString = (result: Record<string, any>) => ({\n  time: mapValuesDeep(result.time, prettyTime),\n  size: mapValuesDeep(result.size, prettyBytes),\n});\n\nconst toMS = (val: number) => Math.round(val / 1000000);\nconst toKB = (val: number) => Math.round(val / 1024);\n\nexport const formatNumber = (result: Record<string, any>) =>\n  mapValues(result, val => ({\n    time: mapValuesDeep(val.time, toMS),\n    size: mapValuesDeep(val.size, toKB),\n  }));\n","import jsonexport from 'jsonexport';\nimport program from 'commander';\nimport fs from 'fs';\n\nimport { cleanup, buildBrowseStorybook } from './buildBrowseStorybook';\nimport { installStorybook } from './installStorybook';\nimport { startStorybook } from './startStorybook';\n\nimport { upload } from './upload';\nimport { formatNumber } from './helpers/format';\nimport { SB_BENCH_UPLOAD } from './environment';\n\nconst stub = (arg?: any) => ({ time: {}, size: {} });\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst save = async (results: Record<string, any>, label: string) => {\n  const csv = await jsonexport(results);\n  fs.writeFileSync(`${label}.csv`, csv);\n  fs.writeFileSync(`${label}.json`, JSON.stringify(results));\n};\n\ninterface Options {\n  installCommand: string;\n  label: string;\n  extraFlags: string[];\n}\n\nconst benchmark = async ({ installCommand, label, extraFlags }: Options) => {\n  await cleanup();\n\n  const install = await installStorybook(installCommand);\n  const start = await startStorybook(extraFlags);\n  const { build, browse } = await buildBrowseStorybook(extraFlags);\n\n  const bench = formatNumber({ install, start, build, browse });\n  await save(bench, label);\n\n  return bench;\n};\n\nexport const main = async () => {\n  program.arguments('<installCommand>');\n  program.option(\n    '-l, --label <label>',\n    'Save as <label>.csv/json and upload with <label> if SB_BENCH_UPLOAD is true',\n    'bench'\n  );\n  program.option(\n    '-e, --extra-flags <flags>',\n    'Run storybook with extra flags (e.g. \"--no-dll\")',\n    ''\n  );\n  program.parse(process.argv);\n  if (!program.args.length) {\n    program.help();\n  }\n\n  const { label, extraFlags } = program;\n  const installCommand = program.args[0];\n  const flags = extraFlags.length > 0 ? extraFlags.split(' ') : [];\n\n  const bench = await benchmark({ installCommand, label, extraFlags: flags });\n  if (SB_BENCH_UPLOAD) {\n    await upload(bench, label);\n  }\n};\n"],"names":["EVENTS","STATS_PORT","puppeteerArgs","now","Date","getTime","resetStats","stats","result","init","time","forEach","evt","makeStatsServer","done","server","Hapi","Server","port","addEvent","event","route","method","path","handler","req","h","console","log","response","code","start","STATIC_STORYBOOK_PORT","makeStaticServer","register","Inert","filePath","join","process","cwd","file","confine","info","uri","STDIO","BUILD_DIR","SCRIPT_REGEX","logger","getScripts","html","Array","from","matchAll","map","m","bundleSize","buildDir","prefix","iframeScripts","indexScripts","preview","find","f","startsWith","manager","Error","du","safeDu","bundleSizes","iframe","fs","readFileSync","toString","index","Promise","all","main","runtime","vendors","docsDll","uiDll","total","cleanup","rimraf","sync","buildBrowseStorybook","extraFlags","Tick","wrap","build","spawnSync","stdio","resolve","promise","res","puppeteer","launch","args","browser","staticServer","statsServer","stop","close","newPage","page","timers","duration","size","bundles","browse","ADDONS_REGEX","insertAddonBench","lines","split","updated","line","replace","installAddonBench","commandArgs","isUsingYarn1","push","mainFile","includes","mainWithBench","writeFileSync","yarnVersionCommand","status","yarnVersion","output","test","NODE_MODULES","installStorybook","installCommand","warn","initialSize","install","cmd","finalSize","MANAGER_PREVIEW_REGEX","PREVIEW_REGEX","DEV_PORT","startStorybook","resolveBuild","buildFinished","resolveRender","renderFinished","child","spawn","managerWebpack","previewWebpack","stdout","on","data","match","exec","parseFloat","kill","webpackStats","GCP_CREDENTIALS","JSON","parse","env","SB_BENCH_UPLOAD","CIRCLE_BRANCH","CIRCLE_SHA1","_gitHelper","error","trim","gitBranch","gitCommit","upload","label","row","branch","commit","timestamp","toISOString","installTime","installSize","startManagerBuild","startPreviewBuild","startManagerRender","managerRender","startPreviewRender","previewRender","buildTime","browseManagerRender","browsePreviewRender","browseSizeTotal","browseSizeManagerTotal","browseSizeManagerVendors","browseSizeManagerUiDll","browseSizePreviewTotal","browseSizePreviewVendors","browseSizePreviewDocsDll","bigquery","BigQuery","projectId","project_id","credentials","dataset","appTable","table","insert","mapValuesDeep","obj","formatFn","mapValues","val","toMS","Math","round","toKB","formatNumber","save","results","jsonexport","csv","stringify","benchmark","bench","program","arguments","option","argv","length","help","flags"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAmKA;AACO,MAAM,eAAe,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC,IAAI,YAAY,CAAC;AA4D/J;AACO,MAAM,oBAAoB,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC,IAAI,iBAAiB,CAAC;AA+UxL;AACA;AACO,SAAS,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE;AACtC,CAAC,IAAI;AACL,EAAE,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC;AACtB,EAAE,CAAC,MAAM,CAAC,EAAE;AACZ,EAAE,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;AACpB,EAAE;AACF,CAAC,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC5B,EAAE,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;AACtC,EAAE;AACF,CAAC,OAAO,MAAM,CAAC;AACf;;AC1jBO,IAAMA,MAAM,GAAG,CAAC,eAAD,EAAkB,eAAlB,EAAmC,aAAnC,CAAf;AACP,AAAO,IAAMC,UAAU,GAAG,IAAnB;AAOP,AAAO,IAAMC,aAAa,GAAG,CAAC,cAAD,EAAiB,0BAAjB,CAAtB;;AAEP,IAAMC,GAAG,GAAG,SAANA,GAAM;AAAA,SAAM,IAAIC,IAAJ,GAAWC,OAAX,EAAN;AAAA,CAAZ;;AAEA,AAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACC,KAAD;AACxB,MAAMC,MAAM,GAAGD,KAAK,IAAK;AAAEE,IAAAA,IAAI,EAAEN,GAAG,EAAX;AAAeO,IAAAA,IAAI,EAAE;AAArB,GAAzB;AACAF,EAAAA,MAAM,CAACC,IAAP,GAAcN,GAAG,EAAjB;AACAH,EAAAA,MAAM,CAACW,OAAP,CAAe,UAAAC,GAAG;AAAA,WAAKJ,MAAM,CAACE,IAAP,CAAYE,GAAZ,IAAmB,IAAxB;AAAA,GAAlB;AACA,SAAOJ,MAAP;AACD,CALM;AAOP,AAAO,IAAMK,eAAe,YAAfA,eAAe,CAAUN,KAAV,EAAwBO,IAAxB;AAAA;AAC1B,QAAMC,MAAM,GAAG,IAAIC,IAAI,CAACC,MAAT,CAAgB;AAAEC,MAAAA,IAAI,EAAEjB;AAAR,KAAhB,CAAf;;AAEA,QAAMkB,QAAQ,GAAG,SAAXA,QAAW,CAACC,KAAD;AACfL,MAAAA,MAAM,CAACM,KAAP,CAAa;AACXC,QAAAA,MAAM,EAAE,KADG;AAEXC,QAAAA,IAAI,QAAMH,KAFC;AAGXI,QAAAA,OAAO,YAASC,GAAT,EAAmBC,CAAnB;AAAA;AACLC,YAAAA,OAAO,CAACC,GAAR,eAAwBR,KAAxB,EAAiCb,KAAjC;;AACA,gBAAI,CAACA,KAAK,CAACG,IAAN,CAAWU,KAAX,CAAL,EAAwB;AACtBb,cAAAA,KAAK,CAACG,IAAN,CAAWU,KAAX,IAAoB,CAACjB,GAAG,KAAKI,KAAK,CAACE,IAAf,IAAuB,OAA3C;AACD;;AACD,gBAAIW,KAAK,KAAK,aAAd,EAA6B;AAC3BN,cAAAA,IAAI;AACL;;AACD,mCAAOY,CAAC,CAACG,QAAF,CAAW,IAAX,EAAiBC,IAAjB,CAAsB,GAAtB,CAAP;AACD,WATM;AAAA;AAAA;AAAA;AAHI,OAAb;AAcD,KAfD;;AAiBA9B,IAAAA,MAAM,CAACW,OAAP,CAAe,UAAAC,GAAG;AAAA,aAAIO,QAAQ,CAACP,GAAD,CAAZ;AAAA,KAAlB;2BACMG,MAAM,CAACgB,KAAP;AACN,aAAOhB,MAAP;;AACD,GAvB2B;AAAA;AAAA;AAAA,CAArB;;ACjBA,IAAMiB,qBAAqB,GAAG,IAA9B;AAEP,AAAO,IAAMC,gBAAgB,YAAhBA,gBAAgB;AAAA;AAC3B,QAAMlB,MAAM,GAAG,IAAIC,IAAI,CAACC,MAAT,CAAgB;AAC7BC,MAAAA,IAAI,EAAEc;AADuB,KAAhB,CAAf;2BAGMjB,MAAM,CAACmB,QAAP,CAAgBC,KAAhB;AAENpB,MAAAA,MAAM,CAACM,KAAP,CAAa;AACXC,QAAAA,MAAM,EAAE,KADG;AAEXC,QAAAA,IAAI,EAAE,WAFK;AAGXC,QAAAA,OAAO,YAASC,GAAT,EAAcC,CAAd;AAAA;AACL,gBAAMU,QAAQ,GAAGb,IAAI,CAACc,IAAL,CAAUC,OAAO,CAACC,GAAR,EAAV,EAAyB,kBAAzB,EAA6Cd,GAAG,CAACF,IAAjD,CAAjB;AACA,mCAAOG,CAAC,CAACc,IAAF,CAAOJ,QAAP,EAAiB;AAAEK,cAAAA,OAAO,EAAE;AAAX,aAAjB,CAAP;AACD,WAHM;AAAA;AAAA;AAAA;AAHI,OAAb;6BASM1B,MAAM,CAACgB,KAAP;AACNJ,QAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ,EAA8Bb,MAAM,CAAC2B,IAAP,CAAYC,GAA1C;AACA,eAAO5B,MAAP;;;AACD,GAlB4B;AAAA;AAAA;AAAA,CAAtB;;ACKP,IAAM6B,KAAK,GAAG,SAAd;AACA,IAAMC,SAAS,GAAG,kBAAlB;AAEA,IAAMC,YAAY,GAAG,gCAArB;AACA,IAAMC,MAAM,GAAGpB,OAAf;;AAEA,IAAMqB,UAAU,GAAG,SAAbA,UAAa,CAACC,IAAD;AACjB;AACA,SAAOC,KAAK,CAACC,IAAN,CAAWF,IAAI,CAACG,QAAL,CAAcN,YAAd,CAAX,EAAwCO,GAAxC,CAA4C,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAAC,CAAD,CAAL;AAAA,GAA7C,CAAP;AACD,CAHD;;AAKA,IAAMC,UAAU,YAAVA,UAAU,CACdC,QADc,EAEdC,MAFc,EAGdC,aAHc,EAIdC,YAJc;AAAA;AAMd,QAAIC,OAAO,GAAGF,aAAa,CAACG,IAAd,CAAmB,UAAAC,CAAC;AAAA,aAAIA,CAAC,CAACC,UAAF,CAAaN,MAAb,CAAJ;AAAA,KAApB,CAAd;AACA,QAAIO,OAAO,GAAGL,YAAY,CAACE,IAAb,CAAkB,UAAAC,CAAC;AAAA,aAAIA,CAAC,CAACC,UAAF,CAAaN,MAAb,CAAJ;AAAA,KAAnB,CAAd;;AAGA,QAAIA,MAAM,KAAK,SAAf,EAA0B;AACxBO,MAAAA,OAAO,GACLA,OAAO,IACPL,YAAY,CAACE,IAAb,CAAkB,UAAAC,CAAC;AAAA,eAAI,CAACA,CAAC,CAACC,UAAF,CAAa,MAAb,CAAD,IAAyB,CAACD,CAAC,CAACC,UAAF,CAAa,SAAb,CAA9B;AAAA,OAAnB,CAFF;AAGAH,MAAAA,OAAO,GACLA,OAAO,IACPF,aAAa,CAACG,IAAd,CACE,UAAAC,CAAC;AAAA,eAAI,CAACA,CAAC,CAACC,UAAF,CAAa,MAAb,CAAD,IAAyB,CAACD,CAAC,CAACC,UAAF,CAAa,SAAb,CAA9B;AAAA,OADH,CAFF;AAKD;;;AAGD,QAAI,CAACH,OAAD,IAAYH,MAAM,KAAK,MAA3B,EAAmC;AACjCG,MAAAA,OAAO,GAAGF,aAAa,CAACG,IAAd,CAAmB,UAAAC,CAAC;AAAA,eAAIA,CAAC,CAACC,UAAF,CAAa,gBAAb,CAAJ;AAAA,OAApB,CAAV;AACD;;AAED,QAAI,CAACC,OAAL,EAAc;AACZ,YAAM,IAAIC,KAAJ,iCAAwCR,MAAxC,SAAN;AACD;;2BAGgBS,EAAE,CAAC3C,IAAI,CAACc,IAAL,CAAUmB,QAAV,EAAoBQ,OAApB,CAAD;;AADnB,eAAO;AACLA,UAAAA,OAAO,KADF;AAELJ,UAAAA,OAAO;AAFF,SAAP;;;qBAEWA;wCAAgBM,EAAE,CAAC3C,IAAI,CAACc,IAAL,CAAUmB,QAAV,EAAoBI,OAApB,CAAD,uBAAiC;;AAE/D,GAlCe;AAAA;AAAA;AAAA,CAAhB;;AAoCA,IAAMO,MAAM,YAANA,MAAM,CAAU/B,QAAV;4CACN;AAAA,2BACW8B,EAAE,CAAC9B,QAAD,CADb;AAEH,iBAAO;AACN,WAAO,CAAP;AACD;AACF,CAND;;AAQA,AAAO,IAAMgC,WAAW,YAAXA,WAAW,CAAUZ,QAAV;AAAA;AACtB,QAAMa,MAAM,GAAGrB,UAAU,CACvBsB,EAAE,CAACC,YAAH,CAAgBhD,IAAI,CAACc,IAAL,CAAUmB,QAAV,EAAoB,aAApB,CAAhB,EAAoDgB,QAApD,EADuB,CAAzB;AAGA,QAAMC,KAAK,GAAGzB,UAAU,CACtBsB,EAAE,CAACC,YAAH,CAAgBhD,IAAI,CAACc,IAAL,CAAUmB,QAAV,EAAoB,YAApB,CAAhB,EAAmDgB,QAAnD,EADsB,CAAxB;2BAIuDE,OAAO,CAACC,GAAR,CAAY,CACjEpB,UAAU,CAACC,QAAD,EAAW,MAAX,EAAmBa,MAAnB,EAA2BI,KAA3B,CADuD,EAEjElB,UAAU,CAACC,QAAD,EAAW,SAAX,EAAsBa,MAAtB,EAA8BI,KAA9B,CAFuD,EAGjElB,UAAU,CAACC,QAAD,EAAW,SAAX,EAAsBa,MAAtB,EAA8BI,KAA9B,CAHuD,EAIjEN,MAAM,CAAC5C,IAAI,CAACc,IAAL,CAAUmB,QAAV,EAAoB,QAApB,EAA8B,uBAA9B,CAAD,CAJ2D,EAKjEW,MAAM,CAAC5C,IAAI,CAACc,IAAL,CAAUmB,QAAV,EAAoB,QAApB,EAA8B,qBAA9B,CAAD,CAL2D,CAAZ;UAAhDoB;UAAMC;UAASC;UAASC;UAASC;AAQxC,aAAO;AACLhB,QAAAA,OAAO,EAAE;AACPiB,UAAAA,KAAK,EAAEL,IAAI,CAACZ,OAAL,GAAea,OAAO,CAACb,OAAvB,GAAiCc,OAAO,CAACd,OADzC;AAEPY,UAAAA,IAAI,EAAEA,IAAI,CAACZ,OAFJ;AAGPa,UAAAA,OAAO,EAAEA,OAAO,CAACb,OAHV;AAIPc,UAAAA,OAAO,EAAEA,OAAO,CAACd,OAJV;AAKPgB,UAAAA,KAAK,EAALA;AALO,SADJ;AAQLpB,QAAAA,OAAO,EAAE;AACPqB,UAAAA,KAAK,EAAEL,IAAI,CAAChB,OAAL,GAAeiB,OAAO,CAACjB,OAAvB,GAAiCkB,OAAO,CAAClB,OADzC;AAEPgB,UAAAA,IAAI,EAAEA,IAAI,CAAChB,OAFJ;AAGPiB,UAAAA,OAAO,EAAEA,OAAO,CAACjB,OAHV;AAIPkB,UAAAA,OAAO,EAAEA,OAAO,CAAClB,OAJV;AAKPmB,UAAAA,OAAO,EAAPA;AALO;AARJ,OAAP;;AAgBD,GAhCuB;AAAA;AAAA;AAAA,CAAjB;AAkCP,AAAO,IAAMG,OAAO,YAAPA,OAAO;AAAA;AAClBC,IAAAA,MAAM,CAACC,IAAP,CAAYvC,SAAZ;;AACD,GAFmB;AAAA;AAAA;AAAA,CAAb;AAIP,AAAO,IAAMwC,oBAAoB,YAApBA,oBAAoB,CAAUC,UAAV;AAAA;AAC/B3D,IAAAA,OAAO,CAACC,GAAR,CAAY,2BAAZ;AAEA2D,IAAAA,IAAI,CAACC,IAAL,CAAU,SAASC,KAAT,CAAe3E,IAAf;AACR4E,MAAAA,IAAS,CAAC,MAAD,GAAU,iBAAV,SAAgCJ,UAAhC,GAA6C;AAAEK,QAAAA,KAAK,EAAE/C;AAAT,OAA7C,CAAT;AACA9B,MAAAA,IAAI;AACL,KAHD;AAKA,QAAI8E,OAAJ;AACA,QAAMC,OAAO,GAAG,IAAInB,OAAJ,CAAY,UAACoB,GAAD;AAC1BF,MAAAA,OAAO,GAAGE,GAAV;AACD,KAFe,CAAhB;AAIA,QAAMvF,KAAK,GAAGD,UAAU,EAAxB;2BACsByF,SAAS,CAACC,MAAV,CAAiB;AAAEC,MAAAA,IAAI,EAAE/F;AAAR,KAAjB,kBAAhBgG;6BAEqBjE,gBAAgB,mBAArCkE;AAEN,YAAIC,WAAJ;+BACoBvF,eAAe,CAACN,KAAD;AAAA;AACjCwC,YAAAA,MAAM,CAACnB,GAAP,CAAW,kBAAX;AACAgE,YAAAA,OAAO;AACP7C,YAAAA,MAAM,CAACnB,GAAP,CAAW,uBAAX;mCACMwE,WAAW,CAACC,IAAZ;AACNtD,cAAAA,MAAM,CAACnB,GAAP,CAAW,wBAAX;qCACMuE,YAAY,CAACE,IAAb;AACNtD,gBAAAA,MAAM,CAACnB,GAAP,CAAW,mBAAX;uCACMsE,OAAO,CAACI,KAAR;;;AACP,WATkC;AAAA;AAAA;AAAA;AAAnCF,UAAAA,WAAW,mBAAX;iCAWmBF,OAAO,CAACK,OAAR,mBAAbC;mCACAA,IAAI,QAAJ,uBAA8BxE,qBAA9B;qCAEA6D;AAEN,oBAAMJ,KAAK,GAAG;AACZ/E,kBAAAA,IAAI,EAAE;AACJ+E,oBAAAA,KAAK,EAAEgB,MAAM,CAAChB,KAAP,CAAaiB,QAAb;AADH,mBADM;AAIZC,kBAAAA,IAAI,EAAE;AAJM,iBAAd;uCAOsBvC,WAAW,CAACvB,SAAD,kBAA3B+D;yCAGW1C,EAAE,CAACrB,SAAD;AAFnB,wBAAMgE,MAAM,GAAG;AACbF,sBAAAA,IAAI;AACF1B,wBAAAA,KAAK;AADH,yBAEC2B,OAFD,CADS;AAKblG,sBAAAA,IAAI,EAAEH,KAAK,CAACG;AALC,qBAAf;AAQA,2BAAO;AAAE+E,sBAAAA,KAAK,EAALA,KAAF;AAASoB,sBAAAA,MAAM,EAANA;AAAT,qBAAP;;;;;;;;;AACD,GApDgC;AAAA;AAAA;AAAA,CAA1B;;ACrGP,IAAMC,YAAY,GAAG,mBAArB;AACA,IAAMlE,OAAK,GAAG,SAAd;;AAEA,IAAMmE,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACnC,IAAD;AACvB,MAAMoC,KAAK,GAAGpC,IAAI,CAACqC,KAAL,CAAW,IAAX,CAAd;AACA,MAAMC,OAAO,GAAGF,KAAK,CAAC3D,GAAN,CAAU,UAAA8D,IAAI;AAAA,WAC5BA,IAAI,CAACC,OAAL,CAAaN,YAAb,EAA2B,8BAA3B,CAD4B;AAAA,GAAd,CAAhB;AAGA,SAAOI,OAAO,CAAC7E,IAAR,CAAa,IAAb,CAAP;AACD,CAND;;AAQA,AAAO,IAAMgF,iBAAiB,YAAjBA,iBAAiB;AAAA;AAC5B,QAAIC,WAAW,GAAG,CAAC,KAAD,EAAQ,wBAAR,EAAkC,OAAlC,CAAlB;;AACA,QAAIC,YAAY,EAAhB,EAAoB;AAClBD,MAAAA,WAAW,CAACE,IAAZ,CAAiB,IAAjB;AACD;;AACD9B,IAAAA,IAAS,CAAC,MAAD,EAAS4B,WAAT,EAAsB;AAC7B3B,MAAAA,KAAK,EAAE/C;AADsB,KAAtB,CAAT;AAGA,QAAM6E,QAAQ,GAAG,oBAAjB;AACA,QAAM7C,IAAI,GAAGN,EAAE,CAACC,YAAH,CAAgBkD,QAAhB,EAA0BjD,QAA1B,EAAb;;AACA,QAAI,CAACI,IAAI,CAAC8C,QAAL,CAAc,wBAAd,CAAL,EAA8C;AAC5C,UAAMC,aAAa,GAAGZ,gBAAgB,CAACnC,IAAD,CAAtC;AACAN,MAAAA,EAAE,CAACsD,aAAH,CAAiBH,QAAjB,EAA2BE,aAA3B;AACD;;;AACF,GAd6B;AAAA;AAAA;AAAA,CAAvB;;AAgBP,IAAMJ,YAAY,GAAG,SAAfA,YAAe;AACnB,MAAMM,kBAAkB,GAAGnC,IAAS,CAAC,MAAD,EAAS,CAAC,WAAD,CAAT,CAApC;;AAEA,MAAImC,kBAAkB,CAACC,MAAnB,KAA8B,CAAlC,EAAqC;AACnC,UAAM,IAAI7D,KAAJ,iEAAN;AACD;;AAED,MAAM8D,WAAW,GAAGF,kBAAkB,CAACG,MAAnB,CACjBxD,QADiB,GAEjB4C,OAFiB,CAET,IAFS,EAEH,EAFG,EAGjBA,OAHiB,CAGT,IAHS,EAGH,EAHG,CAApB;AAKA,SAAO,QAAQa,IAAR,CAAaF,WAAb,CAAP;AACD,CAbD;;ACzBA,IAAMG,YAAY,GAAG,cAArB;AACA,IAAMtF,OAAK,GAAG,SAAd;AAEA,AAAO,IAAMuF,gBAAgB,YAAhBA,gBAAgB,CAAUC,cAAV;AAAA;AAC3BzG,IAAAA,OAAO,CAACC,GAAR,CAAY,mBAAZ;;AACA,QAAI,CAACwG,cAAL,EAAqB;AACnBzG,MAAAA,OAAO,CAAC0G,IAAR,CAAa,6BAAb;AACA,6BAAO;AACL1B,QAAAA,IAAI,EAAE;AAAE1B,UAAAA,KAAK,EAAE;AAAT,SADD;AAELvE,QAAAA,IAAI,EAAE;AAAEuE,UAAAA,KAAK,EAAE;AAAT;AAFD,OAAP;AAID;;2BAEyBf,EAAE,CAACgE,YAAD,kBAAtBI;AACN/C,MAAAA,IAAI,CAACC,IAAL,CAAU,SAAS+C,OAAT,CAAiBzH,IAAjB;oCACesH,cAAc,CAACnB,KAAf,CAAqB,GAArB;YAAhBuB;YAAQvC;;AACfP,QAAAA,IAAS,CAAC8C,GAAD,EAAMvC,IAAN,EAAY;AAAEN,UAAAA,KAAK,EAAE/C;AAAT,SAAZ,CAAT;AACA9B,QAAAA,IAAI;AACL,OAJD;6BAKwBoD,EAAE,CAACgE,YAAD,kBAApBO;AAEN;+BACMpB,iBAAiB;AAEvB,iBAAO;AACLV,YAAAA,IAAI,EAAE;AAAE1B,cAAAA,KAAK,EAAEwD,SAAS,GAAGH;AAArB,aADD;AAEL5H,YAAAA,IAAI,EAAE;AAAEuE,cAAAA,KAAK,EAAEwB,MAAM,CAAC8B,OAAP,CAAe7B,QAAf;AAAT;AAFD,WAAP;;;;AAID,GAzB4B;AAAA;AAAA;AAAA,CAAtB;;ACHP,IAAMgC,qBAAqB,GAAG,gEAA9B;AACA,IAAMC,aAAa,GAAG,kCAAtB;AACA,IAAMC,QAAQ,GAAG,IAAjB;AAEA,IAAM7F,QAAM,GAAGpB,OAAf;AAEA,AAAO,IAAMkH,cAAc,YAAdA,cAAc,CAAUvD,UAAV;AAAA;AACzB3D,IAAAA,OAAO,CAACC,GAAR,CAAY,2BAAZ;AAEA,QAAIkH,YAAJ;AACA,QAAMC,aAAa,GAAG,IAAIrE,OAAJ,CAAY,UAACoB,GAAD;AAChCgD,MAAAA,YAAY,GAAGhD,GAAf;AACD,KAFqB,CAAtB;AAIA,QAAIkD,aAAJ;AACA,QAAMC,cAAc,GAAG,IAAIvE,OAAJ,CAAY,UAACoB,GAAD;AACjCkD,MAAAA,aAAa,GAAGlD,GAAhB;AACD,KAFsB,CAAvB;AAIA,QAAMvF,KAAK,GAAGD,UAAU,EAAxB;AACA,QAAM4I,KAAK,GAAGC,KAAK,CACjB,MADiB,GAEhB,iBAFgB,EAEG,IAFH,EAESP,QAAQ,CAACpE,QAAT,EAFT,EAE8B,MAF9B,SAEyCc,UAFzC,GAGjB;AACEK,MAAAA,KAAK,EAAE;AADT,KAHiB,CAAnB;AAQA,QAAIyD,cAAc,GAAG,CAAC,CAAtB;AACA,QAAIC,cAAc,GAAG,CAAC,CAAtB;AAEA;AACA;AACA;;AACAH,IAAAA,KAAK,CAACI,MAAN,CAAaC,EAAb,CAAgB,MAAhB,EAAwB,UAAAC,IAAI;AAC1B,UAAMxB,MAAM,GAAGwB,IAAI,CAAChF,QAAL,EAAf;;AAEA,UAAIiF,KAAK,GAAGf,qBAAqB,CAACgB,IAAtB,CAA2B1B,MAA3B,CAAZ;;AACA,UAAIyB,KAAJ,EAAW;AACT9H,QAAAA,OAAO,CAACC,GAAR,CAAY;AAAE6H,UAAAA,KAAK,EAALA;AAAF,SAAZ;AACAL,QAAAA,cAAc,GAAG,aAAaO,UAAU,CAACF,KAAK,CAAC,CAAD,CAAN,CAAxC;AACAJ,QAAAA,cAAc,GAAG,aAAaM,UAAU,CAACF,KAAK,CAAC,CAAD,CAAN,CAAxC;AACAX,QAAAA,YAAY;AACb;;;AAEDW,MAAAA,KAAK,GAAGd,aAAa,CAACe,IAAd,CAAmB1B,MAAnB,CAAR;;AACA,UAAIyB,KAAJ,EAAW;AACT9H,QAAAA,OAAO,CAACC,GAAR,CAAY;AAAE6H,UAAAA,KAAK,EAALA;AAAF,SAAZ;AACAL,QAAAA,cAAc,GAAG,CAAjB;AACAC,QAAAA,cAAc,GAAG,aAAaM,UAAU,CAACF,KAAK,CAAC,CAAD,CAAN,CAAxC;AACAX,QAAAA,YAAY;AACb;AACF,KAlBD;AAmBAI,IAAAA,KAAK,CAACK,EAAN,CAAS,MAAT,EAAiB;AACfxG,MAAAA,QAAM,CAACnB,GAAP,CAAW,yBAAX;AACAoH,MAAAA,aAAa;AACd,KAHD;AAIA,QAAI5C,WAAJ;2BAEsBL,SAAS,CAACC,MAAV,CAAiB;AAAEC,MAAAA,IAAI,EAAE/F;AAAR,KAAjB,kBAAhBgG;6BAEcrF,eAAe,CAACN,KAAD;AAAA;AACjCwC,UAAAA,QAAM,CAACnB,GAAP,CAAW,yBAAX;AACAsH,UAAAA,KAAK,CAACU,IAAN;AACA7G,UAAAA,QAAM,CAACnB,GAAP,CAAW,uBAAX;iCACMwE,WAAW,CAACC,IAAZ;AACNtD,YAAAA,QAAM,CAACnB,GAAP,CAAW,mBAAX;mCACMsE,OAAO,CAACI,KAAR;;AACP,SAPkC;AAAA;AAAA;AAAA;AAAnCF,QAAAA,WAAW,mBAAX;+BASM2C;iCAEa7C,OAAO,CAACK,OAAR,mBAAbC;mCACAA,IAAI,QAAJ,uBAA8BoC,QAA9B;qCACAK;AAEN,oBAAMY,YAAY,GAAG;AACnBT,kBAAAA,cAAc,EAAdA,cADmB;AAEnBC,kBAAAA,cAAc,EAAdA;AAFmB,iBAArB;AAKA,uBAAO;AACL3I,kBAAAA,IAAI,eACCmJ,YADD,EAECtJ,KAAK,CAACG,IAFP,CADC;AAKLiG,kBAAAA,IAAI,EAAE;AALD,iBAAP;;;;;;;AAOD,GAlF0B;AAAA;AAAA;AAAA,CAApB;;ACXP,IAAMmD,eAAe,gBAAGC,IAAI,CAACC,KAAL,CAAW1H,OAAO,CAAC2H,GAAR,CAAYH,eAAZ,IAA+B,IAA1C,CAAxB;AACA,IAAMI,eAAe,GAAG5H,OAAO,CAAC2H,GAAR,CAAYC,eAAZ,KAAgC,MAAxD;mBACuC5H,OAAO,CAAC2H;IAAvCE,6BAAAA;IAAeC,2BAAAA;;ACGvB,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACpE,IAAD;AACjB,MAAMzF,MAAM,GAAGkF,IAAS,CAAC,KAAD,EAAQO,IAAR,EAAc;AAAEN,IAAAA,KAAK,EAAE;AAAT,GAAd,CAAxB;;AACA,MAAInF,MAAM,CAAC8J,KAAX,EAAkB;AAChB,UAAM9J,MAAM,CAAC8J,KAAb;AACD;;AACD,SAAO9J,MAAM,CAACwH,MAAP,CAAc3F,IAAd,CAAmB,IAAnB,EAAyBkI,IAAzB,EAAP;AACD,CAND;;AAQA,IAAMC,SAAS,GAAG,SAAZA,SAAY;AAAA,SAAMH,UAAU,CAAC,CAAC,WAAD,EAAc,cAAd,EAA8B,MAA9B,CAAD,CAAhB;AAAA,CAAlB;;AACA,IAAMI,SAAS,GAAG,SAAZA,SAAY;AAAA,SAAMJ,UAAU,CAAC,CAAC,WAAD,EAAc,MAAd,CAAD,CAAhB;AAAA,CAAlB;;AAEA,AAAO,IAAMK,MAAM,YAANA,MAAM,OAEjBC,KAFiB;AAAA,MACfpC,OADe,QACfA,OADe;AAAA,MACNxG,KADM,QACNA,KADM;AAAA,MACC0D,KADD,QACCA,KADD;AAAA,MACQoB,MADR,QACQA,MADR;;AAAA;AAIjBlF,IAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ,EAAkC+I,KAAlC;AAEA,QAAMC,GAAG,GAAG;AACVC,MAAAA,MAAM,EAAEV,aAAa,IAAIK,SAAS,EADxB;AAEVM,MAAAA,MAAM,EAAEV,WAAW,IAAIK,SAAS,EAFtB;AAGVM,MAAAA,SAAS,EAAE,IAAI3K,IAAJ,GAAW4K,WAAX,EAHD;AAIVL,MAAAA,KAAK,EAALA,KAJU;AAKVM,MAAAA,WAAW,EAAE1C,OAAO,CAAC7H,IAAR,CAAauE,KALhB;AAMViG,MAAAA,WAAW,EAAE3C,OAAO,CAAC5B,IAAR,CAAa1B,KANhB;AAOVkG,MAAAA,iBAAiB,EAAEpJ,KAAK,CAACrB,IAAN,CAAW0I,cAPpB;AAQVgC,MAAAA,iBAAiB,EAAErJ,KAAK,CAACrB,IAAN,CAAW2I,cARpB;AASVgC,MAAAA,kBAAkB,EAAEtJ,KAAK,CAACrB,IAAN,CAAW4K,aATrB;AAUVC,MAAAA,kBAAkB,EAAExJ,KAAK,CAACrB,IAAN,CAAW8K,aAVrB;AAWVC,MAAAA,SAAS,EAAEhG,KAAK,CAAC/E,IAAN,CAAW+E,KAXZ;AAYViG,MAAAA,mBAAmB,EAAE7E,MAAM,CAACnG,IAAP,CAAY4K,aAZvB;AAaVK,MAAAA,mBAAmB,EAAE9E,MAAM,CAACnG,IAAP,CAAY8K,aAbvB;AAcVI,MAAAA,eAAe,EAAE/E,MAAM,CAACF,IAAP,CAAY1B,KAdnB;AAeV4G,MAAAA,sBAAsB,EAAEhF,MAAM,CAACF,IAAP,CAAY3C,OAAZ,CAAoBiB,KAflC;AAgBV6G,MAAAA,wBAAwB,EAAEjF,MAAM,CAACF,IAAP,CAAY3C,OAAZ,CAAoBc,OAhBpC;AAiBViH,MAAAA,sBAAsB,EAAElF,MAAM,CAACF,IAAP,CAAY3C,OAAZ,CAAoBgB,KAjBlC;AAkBVgH,MAAAA,sBAAsB,EAAEnF,MAAM,CAACF,IAAP,CAAY/C,OAAZ,CAAoBqB,KAlBlC;AAmBVgH,MAAAA,wBAAwB,EAAEpF,MAAM,CAACF,IAAP,CAAY/C,OAAZ,CAAoBkB,OAnBpC;AAoBVoH,MAAAA,wBAAwB,EAAErF,MAAM,CAACF,IAAP,CAAY/C,OAAZ,CAAoBmB;AApBpC,KAAZ;AAuBA,QAAMoH,QAAQ,GAAG,IAAIC,QAAJ,CAAa;AAC5BC,MAAAA,SAAS,EAAEvC,eAAe,CAACwC,UADC;AAE5BC,MAAAA,WAAW,EAAEzC;AAFe,KAAb,CAAjB;AAIA,QAAM0C,OAAO,GAAGL,QAAQ,CAACK,OAAT,CAAiB,mBAAjB,CAAhB;AACA,QAAMC,QAAQ,GAAGD,OAAO,CAACE,KAAR,CAAc,OAAd,CAAjB;2BAEMD,QAAQ,CAACE,MAAT,CAAgB,CAAC/B,GAAD,CAAhB;AACP,GArCkB;AAAA;AAAA;AAAA,CAAZ;;ACXP,IAAMgC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,GAAD,EAAWC,QAAX;AAAA,SACpB,OAAOD,GAAP,KAAe,QAAf,GACIE,SAAS,CAACF,GAAD,EAAM,UAAAG,GAAG;AAAA,WAAIJ,aAAa,CAACI,GAAD,EAAMF,QAAN,CAAjB;AAAA,GAAT,CADb,GAEIA,QAAQ,CAACD,GAAD,CAHQ;AAAA,CAAtB;;AAUA,IAAMI,IAAI,GAAG,SAAPA,IAAO,CAACD,GAAD;AAAA,SAAiBE,IAAI,CAACC,KAAL,CAAWH,GAAG,GAAG,OAAjB,CAAjB;AAAA,CAAb;;AACA,IAAMI,IAAI,GAAG,SAAPA,IAAO,CAACJ,GAAD;AAAA,SAAiBE,IAAI,CAACC,KAAL,CAAWH,GAAG,GAAG,IAAjB,CAAjB;AAAA,CAAb;;AAEA,AAAO,IAAMK,YAAY,GAAG,SAAfA,YAAe,CAAC7M,MAAD;AAAA,SAC1BuM,SAAS,CAACvM,MAAD,EAAS,UAAAwM,GAAG;AAAA,WAAK;AACxBtM,MAAAA,IAAI,EAAEkM,aAAa,CAACI,GAAG,CAACtM,IAAL,EAAWuM,IAAX,CADK;AAExBtG,MAAAA,IAAI,EAAEiG,aAAa,CAACI,GAAG,CAACrG,IAAL,EAAWyG,IAAX;AAFK,KAAL;AAAA,GAAZ,CADiB;AAAA,CAArB;;ACHP,IAAME,IAAI,YAAJA,IAAI,CAAUC,OAAV,EAAwC5C,KAAxC;AAAA;2BACU6C,UAAU,CAACD,OAAD,kBAAtBE;AACNnJ,MAAAA,EAAE,CAACsD,aAAH,CAAoB+C,KAApB,WAAiC8C,GAAjC;AACAnJ,MAAAA,EAAE,CAACsD,aAAH,CAAoB+C,KAApB,YAAkCZ,IAAI,CAAC2D,SAAL,CAAeH,OAAf,CAAlC;;AACD,GAJS;AAAA;AAAA;AAAA,CAAV;;AAYA,IAAMI,SAAS,YAATA,SAAS;AAAA,MAAYvF,cAAZ,QAAYA,cAAZ;AAAA,MAA4BuC,KAA5B,QAA4BA,KAA5B;AAAA,MAAmCrF,UAAnC,QAAmCA,UAAnC;;AAAA;2BACPJ,OAAO;6BAESiD,gBAAgB,CAACC,cAAD,kBAAhCG;+BACcM,cAAc,CAACvD,UAAD,kBAA5BvD;iCAC0BsD,oBAAoB,CAACC,UAAD;gBAA5CG,cAAAA;gBAAOoB,eAAAA;AAEf,gBAAM+G,KAAK,GAAGP,YAAY,CAAC;AAAE9E,cAAAA,OAAO,EAAPA,OAAF;AAAWxG,cAAAA,KAAK,EAALA,KAAX;AAAkB0D,cAAAA,KAAK,EAALA,KAAlB;AAAyBoB,cAAAA,MAAM,EAANA;AAAzB,aAAD,CAA1B;mCACMyG,IAAI,CAACM,KAAD,EAAQjD,KAAR;AAEV,qBAAOiD,KAAP;;;;;;AACD,GAXc;AAAA;AAAA;AAAA,CAAf;;AAaA,IAAahJ,IAAI,YAAJA,IAAI;AAAA;AACfiJ,IAAAA,OAAO,CAACC,SAAR,CAAkB,kBAAlB;AACAD,IAAAA,OAAO,CAACE,MAAR,CACE,qBADF,EAEE,6EAFF,EAGE,OAHF;AAKAF,IAAAA,OAAO,CAACE,MAAR,CACE,2BADF,EAEE,kDAFF,EAGE,EAHF;AAKAF,IAAAA,OAAO,CAAC7D,KAAR,CAAc1H,OAAO,CAAC0L,IAAtB;;AACA,QAAI,CAACH,OAAO,CAAC5H,IAAR,CAAagI,MAAlB,EAA0B;AACxBJ,MAAAA,OAAO,CAACK,IAAR;AACD;;QAEOvD,QAAsBkD,QAAtBlD;QAAOrF,aAAeuI,QAAfvI;AACf,QAAM8C,cAAc,GAAGyF,OAAO,CAAC5H,IAAR,CAAa,CAAb,CAAvB;AACA,QAAMkI,KAAK,GAAG7I,UAAU,CAAC2I,MAAX,GAAoB,CAApB,GAAwB3I,UAAU,CAAC2B,KAAX,CAAiB,GAAjB,CAAxB,GAAgD,EAA9D;2BAEoB0G,SAAS,CAAC;AAAEvF,MAAAA,cAAc,EAAdA,cAAF;AAAkBuC,MAAAA,KAAK,EAALA,KAAlB;AAAyBrF,MAAAA,UAAU,EAAE6I;AAArC,KAAD,kBAAvBP;;YACF1D;iCACIQ,MAAM,CAACkD,KAAD,EAAQjD,KAAR;;;;;;AAEf,GAzBgB;AAAA;AAAA;AAAA,CAAV;;;;"}
\ No newline at end of file
